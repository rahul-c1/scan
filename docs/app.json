[{"name":"app.R","content":"library(shiny)\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(DT)\n# Workaround for Chromium Issue 468227\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n\n# Sample data structure (replace with your actual data loading)\n# Assuming your data has columns: scan_date, scan_symbol, symbol\n# create_sample_data <- function() {\n#   # This function creates sample data - replace with your actual data loading\n#   dates <- seq(as.Date(\"2024-01-01\"), as.Date(\"2024-12-31\"), by = \"week\")\n#   scan_types <- c(\"CarusoInsights\", \"roc_mdt25\")\n#   symbols_pool <- c(\"AGX\", \"AMSC\", \"CAMT\", \"CENX\", \"CS\", \"HNRG\", \"EL\", \"ATRO\", \"CYBN\", \"PRAX\")\n#   \n#   sample_data <- data.table(\n#     scan_date = sample(dates, 1000, replace = TRUE),\n#     scan_symbol = sample(scan_types, 1000, replace = TRUE),\n#     symbol = sample(symbols_pool, 1000, replace = TRUE)\n#   )\n#   \n#   return(sample_data)\n# }\n\ncreate_sample_data <- function() {\nsample_data <- fread(\"https://raw.githubusercontent.com/rahul-c1/scan/refs/heads/main/weekly_scans.csv\")\nsample_data$date <- as.Date(sample_data$date)\nsetnames(sample_data,\"scan\",\"scan_symbol\")\nsetnames(sample_data,\"date\",\"scan_date\")\n}\n# UI\nui <- navbarPage(\n  title = \"Trading Scan Analysis Dashboard\",\n  theme = \"bootstrap.min.css\",\n  \n  # Tab 1: Scan Frequency Analyzer\n  tabPanel(\"Scan Frequency\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Filters\"),\n                      dateRangeInput(\"freq_date_range\", \"Date Range:\",\n                                     start = Sys.Date() - 90,\n                                     end = Sys.Date()),\n                      selectInput(\"freq_scan_type\", \"Scan Type:\",\n                                  choices = NULL,\n                                  multiple = TRUE),\n                      numericInput(\"freq_min_appearances\", \"Min Appearances:\",\n                                   value = 1, min = 1),\n                      actionButton(\"freq_update\", \"Update Analysis\", class = \"btn-primary\")\n                    )\n             ),\n             column(8,\n                    plotOutput(\"freq_plot\"),\n                    DT::dataTableOutput(\"freq_table\")\n             )\n           )\n  ),\n  \n  # Tab 2: Scan Pattern Dashboard\n  tabPanel(\"Scan Patterns\",\n           fluidRow(\n             column(3,\n                    wellPanel(\n                      h4(\"Pattern Analysis\"),\n                      dateRangeInput(\"pattern_date_range\", \"Date Range:\",\n                                     start = Sys.Date() - 180,\n                                     end = Sys.Date()),\n                      selectInput(\"pattern_view\", \"View Type:\",\n                                  choices = list(\"Heatmap\" = \"heatmap\",\n                                                 \"Time Series\" = \"timeseries\",\n                                                 \"Weekly Breakdown\" = \"weekly\")),\n                      actionButton(\"pattern_update\", \"Update\", class = \"btn-primary\")\n                    )\n             ),\n             column(9,\n                    plotOutput(\"pattern_plot\", height = \"500px\"),\n                    DT::dataTableOutput(\"pattern_summary\")\n             )\n           )\n  ),\n  \n  # Tab 3: Symbol Momentum Tracker\n  tabPanel(\"Momentum Tracker\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Momentum Settings\"),\n                      numericInput(\"momentum_weeks\", \"Analysis Period (weeks):\",\n                                   value = 2, min = 2, max = 12),\n                      numericInput(\"momentum_threshold\", \"Momentum Threshold:\",\n                                   value = 100, min = 0, max = 1000),\n                      selectInput(\"momentum_type\", \"Momentum Type:\",\n                                  choices = list(\"Heating Up\" = \"Heating Up\",\n                                                 \"Cooling Down\" = \"Cooling Down\",\n                                                 \"Both\" = \"both\")),\n                      actionButton(\"momentum_update\", \"Analyze Momentum\", class = \"btn-primary\")\n                    ),\n                    wellPanel(\n                      h4(\"Hot Symbols Alert\"),\n                      verbatimTextOutput(\"hot_symbols\")\n                    )\n             ),\n             column(8,\n                    plotOutput(\"momentum_plot\"),\n                    DT::dataTableOutput(\"momentum_table\")\n             )\n           )\n  ),\n  \n  # Tab 4: Scan Correlation Matrix\n  # tabPanel(\"Correlations\",\n  #          fluidRow(\n  #            column(3,\n  #                   wellPanel(\n  #                     h4(\"Correlation Analysis\"),\n  #                     dateRangeInput(\"corr_date_range\", \"Date Range:\",\n  #                                    start = Sys.Date() - 90,\n  #                                    end = Sys.Date()),\n  #                     numericInput(\"corr_min_freq\", \"Min Symbol Frequency:\",\n  #                                  value = 5, min = 1),\n  #                     actionButton(\"corr_update\", \"Calculate\", class = \"btn-primary\")\n  #                   )\n  #            ),\n  #            column(9,\n  #                   plotOutput(\"correlation_heatmap\", height = \"400px\"),\n  #                   h4(\"Scan Co-occurrence Analysis\"),\n  #                   DT::dataTableOutput(\"correlation_table\")\n  #            )\n  #          )\n  # ),\n  \n  # Tab 5: Portfolio Screening\n  tabPanel(\"Portfolio Screen\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Portfolio Input\"),\n                      textAreaInput(\"portfolio_symbols\", \"Enter Symbols (one per line):\",\n                                    value = \"AGX\\nBE\\nPLTR\", height = \"150px\"),\n                      dateRangeInput(\"portfolio_date_range\", \"Analysis Period:\",\n                                     start = Sys.Date() - 30,\n                                     end = Sys.Date()),\n                      actionButton(\"portfolio_analyze\", \"Analyze Portfolio\", class = \"btn-primary\")\n                    ),\n                    wellPanel(\n                      h4(\"Portfolio Metrics\"),\n                      verbatimTextOutput(\"portfolio_metrics\")\n                    )\n             ),\n             column(8,\n                    plotOutput(\"portfolio_plot\"),\n                    h4(\"Portfolio Scan Activity\"),\n                    DT::dataTableOutput(\"portfolio_table3\")\n                    #DT::dataTableOutput(\"portfolio_table2\")\n                    #DT::dataTableOutput(\"portfolio_table\")\n                    #plotOutput(\"portfolio_table3\")\n             )\n           )\n  ),\n  \n  # Tab 6: Signal Strength Calculator\n  tabPanel(\"Signal Strength\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Signal Weights\"),\n                      p(\"Assign weights to each scan type:\"),\n                      uiOutput(\"weight_inputs\"),\n                      br(),\n                      numericInput(\"signal_min_score\", \"Min Signal Score:\",\n                                   value = 50, min = 0, max = 100),\n                      actionButton(\"signal_calculate\", \"Calculate Signals\", class = \"btn-primary\")\n                    )\n             ),\n             column(8,\n                    plotOutput(\"signal_plot\"),\n                    h4(\"Top Signal Strength Symbols\"),\n                    DT::dataTableOutput(\"signal_table\")\n             )\n           )\n  ),\n  \n  # Tab 7: Historical Performance\n  tabPanel(\"Historical Analysis\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Backtest Settings\"),\n                      dateRangeInput(\"hist_date_range\", \"Analysis Period:\",\n                                     start = Sys.Date() - 180,\n                                     end = Sys.Date()),\n                      selectInput(\"hist_scan_type\", \"Focus Scan Type:\",\n                                  choices = NULL),\n                      numericInput(\"hist_lookback\", \"Lookback Days:\",\n                                   value = 7, min = 1, max = 30),\n                      actionButton(\"hist_analyze\", \"Run Analysis\", class = \"btn-primary\")\n                    )\n             ),\n             column(8,\n                    plotOutput(\"historical_plot\"),\n                    h4(\"Scan Effectiveness Metrics\"),\n                    DT::dataTableOutput(\"historical_table\")\n             )\n           )\n  ),\n  \n  # Tab 8: Alert System\n  tabPanel(\"Alert System\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Alert Settings\"),\n                      selectInput(\"alert_symbols\", \"Watch Symbols:\",\n                                  choices = NULL, multiple = TRUE),\n                      selectInput(\"alert_scan_types\", \"Watch Scan Types:\",\n                                  choices = NULL, multiple = TRUE),\n                      numericInput(\"alert_frequency_threshold\", \"Frequency Threshold:\",\n                                   value = 3, min = 1),\n                      checkboxInput(\"alert_new_symbols\", \"Alert on New Symbols\", TRUE),\n                      actionButton(\"alert_setup\", \"Setup Alerts\", class = \"btn-primary\")\n                    ),\n                    wellPanel(\n                      h4(\"Active Alerts\"),\n                      verbatimTextOutput(\"active_alerts\")\n                    )\n             ),\n             column(8,\n                    h4(\"Recent Alert Activity\"),\n                    DT::dataTableOutput(\"alert_table\"),\n                    br(),\n                    plotOutput(\"alert_timeline\")\n             )\n           )\n  ),\n  # Tab 10: Bulk Symbol Scanner\n  tabPanel(\"Bulk Scanner\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Bulk Symbol Analysis\"),\n                      textAreaInput(\"bulk_symbols\", \"Enter Symbols (one per line, comma or space separated):\",\n                                    value = \"\", height = \"200px\"),\n                      fileInput(\"bulk_upload\", \"Or Upload CSV/TXT File:\",\n                                accept = c(\".csv\", \".txt\")),\n                      dateRangeInput(\"bulk_date_range\", \"Analysis Period:\",\n                                     start = Sys.Date() - 60,\n                                     end = Sys.Date()),\n                      selectInput(\"bulk_scan_filter\", \"Filter by Scan Types:\",\n                                  choices = NULL, multiple = TRUE),\n                      numericInput(\"bulk_min_scans\", \"Minimum Scans Required:\",\n                                   value = 1, min = 0),\n                      actionButton(\"bulk_analyze\", \"Run Bulk Analysis\", class = \"btn-success\"),\n                      br(), br(),\n                      downloadButton(\"bulk_download\", \"Download Results\", class = \"btn-info\")\n                    )\n             ),\n             column(8,\n                    tabsetPanel(\n                      tabPanel(\"Results Table\",\n                               h4(\"Bulk Scan Results\"),\n                               DT::dataTableOutput(\"bulk_results_table\")\n                      ),\n                      tabPanel(\"Scan Matrix\",\n                               h4(\"Symbol vs Scan Type Matrix\"),\n                               DT::dataTableOutput(\"bulk_matrix_table\")\n                      ),\n                      tabPanel(\"Summary Stats\",\n                               fluidRow(\n                                 column(6,\n                                        h4(\"Coverage Analysis\"),\n                                        plotOutput(\"bulk_coverage_plot\", height = \"300px\")\n                                 ),\n                                 column(6,\n                                        h4(\"Scan Distribution\"),\n                                        plotOutput(\"bulk_distribution_plot\", height = \"300px\")\n                                 )\n                               ),\n                               h4(\"Bulk Analysis Summary\"),\n                               verbatimTextOutput(\"bulk_summary_stats\")\n                      )\n                    )\n             )\n           )\n  ),\n  # Tab 11: Trading Log\n  tabPanel(\"Trading Log\",\n           fluidRow(\n             column(4,\n                    wellPanel(\n                      h4(\"Add New Trade\"),\n                      selectizeInput(\"trade_symbol\", \"Symbol:\",\n                                     choices = NULL, options = list(create = TRUE)),\n                      radioButtons(\"trade_action\", \"Action:\",\n                                   choices = list(\"Buy\" = \"buy\", \"Sell\" = \"sell\"),\n                                   selected = \"buy\", inline = TRUE),\n                      dateInput(\"trade_date\", \"Trade Date:\", value = Sys.Date()),\n                      textInput(\"trade_time\", \"Trade Time (HH:MM):\", value = format(Sys.time(), \"%H:%M\")),\n #                     timeInput(\"trade_time\", \"Trade Time:\", value = Sys.time()),\n                      numericInput(\"trade_price\", \"Entry Price ($):\", value = 0, min = 0, step = 0.01),\n                      numericInput(\"trade_quantity\", \"Quantity:\", value = 100, min = 1),\n                      numericInput(\"trade_target\", \"Target Price ($):\", value = 0, min = 0, step = 0.01),\n                      numericInput(\"trade_stop\", \"Stop Loss ($):\", value = 0, min = 0, step = 0.01),\n                      selectInput(\"trade_entry_criteria\", \"Entry Criteria:\",\n                                  choices = list(\n                                    \"OpenEqualsLow\" = \"OpenEqualsLow\",\n                                    \"4percent\" = \"4percent\", \n                                    \"21dayBreakout\" = \"21dayBreakout\",\n                                    \"VolumeSpike\" = \"VolumeSpike\",\n                                    \"GapUp\" = \"GapUp\",\n                                    \"BreakoutPattern\" = \"BreakoutPattern\",\n                                    \"ScanAlert\" = \"ScanAlert\",\n                                    \"TechnicalSetup\" = \"TechnicalSetup\",\n                                    \"NewsEvent\" = \"NewsEvent\",\n                                    \"Other\" = \"Other\"\n                                  )),\n                      selectInput(\"trade_scan_source\", \"Scan Source:\",\n                                  choices = NULL, multiple = TRUE),\n                      textAreaInput(\"trade_notes\", \"Trade Notes:\", height = \"100px\"),\n                      br(),\n                      actionButton(\"add_trade\", \"Add Trade\", class = \"btn-primary\"),\n                      actionButton(\"update_trade\", \"Update Selected\", class = \"btn-warning\"),\n                      actionButton(\"delete_trade\", \"Delete Selected\", class = \"btn-danger\")\n                    ),\n wellPanel(\n   h4(\"Close Selected Trade\"),\n   numericInput(\"exit_price\", \"Exit Price ($):\", value = 0, min = 0, step = 0.01),\n   dateInput(\"exit_date\", \"Exit Date:\", value = Sys.Date()),\n   textInput(\"exit_time\", \"Exit Time (HH:MM):\", value = format(Sys.time(), \"%H:%M\")),\n   textAreaInput(\"exit_notes\", \"Exit Notes:\", height = \"60px\"),\n   br(),\n   actionButton(\"close_trade\", \"Close Selected Trade\", class = \"btn-warning\"),\n   br(), br(),\n   verbatimTextOutput(\"selected_trade_info\")\n ),\n                    wellPanel(\n                      h4(\"Quick Actions\"),\n                      selectInput(\"quick_symbol_filter\", \"Filter by Symbol:\", \n                                  choices = NULL, multiple = TRUE),\n                      selectInput(\"quick_status_filter\", \"Filter by Status:\",\n                                  choices = list(\"All\" = \"all\", \"Open\" = \"open\", \"Closed\" = \"closed\")),\n                      dateRangeInput(\"quick_date_filter\", \"Date Range:\",\n                                     start = Sys.Date() - 30, end = Sys.Date()),\n                      downloadButton(\"download_trades\", \"Download Trading Log\", class = \"btn-success\"),\n                      # Add this button in the Quick Actions wellPanel:\n                      actionButton(\"bulk_close_trades\", \"View Open Trades\", class = \"btn-info\")\n                    )\n \n             ),\n             column(8,\n                    tabsetPanel(\n                      tabPanel(\"Trading Log\",\n                               DT::dataTableOutput(\"trading_log_table\")\n                      ),\n                      tabPanel(\"Performance Dashboard\",\n                               fluidRow(\n                                 column(6,\n                                        h4(\"P&L Summary\"),\n                                        verbatimTextOutput(\"pnl_summary\")\n                                 ),\n                                 column(6,\n                                        h4(\"Trade Statistics\"),\n                                        verbatimTextOutput(\"trade_stats\")\n                                 )\n                               ),\n                               fluidRow(\n                                 column(6,\n                                        plotOutput(\"pnl_chart\", height = \"300px\")\n                                 ),\n                                 column(6,\n                                        plotOutput(\"win_loss_chart\", height = \"300px\")\n                                 )\n                               )\n                      ),\n                      tabPanel(\"Strategy Analysis\",\n                               fluidRow(\n                                 column(6,\n                                        h4(\"Entry Criteria Performance\"),\n                                        plotOutput(\"entry_criteria_chart\", height = \"300px\")\n                                 ),\n                                 column(6,\n                                        h4(\"Scan Source Performance\"),\n                                        plotOutput(\"scan_source_chart\", height = \"300px\")\n                                 )\n                               ),\n                               h4(\"Strategy Performance Table\"),\n                               DT::dataTableOutput(\"strategy_performance_table\")\n                      ),\n                      tabPanel(\"Risk Analysis\",\n                               fluidRow(\n                                 column(6,\n                                        h4(\"Position Sizing Distribution\"),\n                                        plotOutput(\"position_size_chart\", height = \"300px\")\n                                 ),\n                                 column(6,\n                                        h4(\"Risk-Reward Analysis\"),\n                                        plotOutput(\"risk_reward_chart\", height = \"300px\")\n                                 )\n                               ),\n                               h4(\"Risk Metrics\"),\n                               DT::dataTableOutput(\"risk_metrics_table\")\n                      )\n                    )\n             )\n           )\n  )\n)\n\n# Server\nserver <- function(input, output, session) {\n  \n  \n  \n  # Add this reactive function to read the CSV file\n  csv_trading_log <- reactive({\n    tryCatch({\n      if (class(read.csv2(\"https://raw.githubusercontent.com/rahul-c1/scan/refs/heads/main/trading_log.csv\"))==\"data.frame\") {\n        csv_data <- fread(\"https://raw.githubusercontent.com/rahul-c1/scan/refs/heads/main/trading_log.csv\")\n        \n        # Ensure proper data types\n        if (nrow(csv_data) > 0) {\n          csv_data[, trade_date := as.Date(trade_date)]\n          csv_data[, trade_time := as.POSIXct(trade_time)]\n          csv_data[, created_at := as.POSIXct(created_at)]\n          csv_data[, updated_at := as.POSIXct(updated_at)]\n          \n          # Ensure all required columns exist\n          required_cols <- c(\"trade_id\", \"symbol\", \"action\", \"trade_date\", \"trade_time\", \n                             \"entry_price\", \"exit_price\", \"quantity\", \"target_price\", \n                             \"stop_loss\", \"entry_criteria\", \"scan_source\", \"notes\", \n                             \"status\", \"pnl\", \"pnl_percent\", \"created_at\", \"updated_at\")\n          \n          missing_cols <- setdiff(required_cols, names(csv_data))\n          if (length(missing_cols) > 0) {\n            for (col in missing_cols) {\n              if (col %in% c(\"pnl\", \"pnl_percent\", \"entry_price\", \"exit_price\", \"target_price\", \"stop_loss\")) {\n                csv_data[[col]] <- as.numeric(NA)\n              } else if (col %in% c(\"trade_date\")) {\n                csv_data[[col]] <- as.Date(NA)\n              } else if (col %in% c(\"trade_time\", \"created_at\", \"updated_at\")) {\n                csv_data[[col]] <- as.POSIXct(NA)\n              } else if (col == \"trade_id\") {\n                csv_data[[col]] <- as.integer(NA)\n              } else if (col == \"quantity\") {\n                csv_data[[col]] <- as.integer(0)\n              } else {\n                csv_data[[col]] <- as.character(\"\")\n              }\n            }\n          }\n          \n          return(csv_data[order(-trade_date, -trade_time)])\n        }\n      }\n      # Return empty data.table with correct structure if file doesn't exist\n      return(data.table(\n        trade_id = integer(),\n        symbol = character(),\n        action = character(),\n        trade_date = as.Date(character()),\n        trade_time = as.POSIXct(character()),\n        entry_price = numeric(),\n        exit_price = numeric(),\n        quantity = integer(),\n        target_price = numeric(),\n        stop_loss = numeric(),\n        entry_criteria = character(),\n        scan_source = character(),\n        notes = character(),\n        status = character(),\n        pnl = numeric(),\n        pnl_percent = numeric(),\n        created_at = as.POSIXct(character()),\n        updated_at = as.POSIXct(character())\n      ))\n    }, error = function(e) {\n      # Return empty data.table on error\n      return(data.table(\n        trade_id = integer(),\n        symbol = character(),\n        action = character(),\n        trade_date = as.Date(character()),\n        trade_time = as.POSIXct(character()),\n        entry_price = numeric(),\n        exit_price = numeric(),\n        quantity = integer(),\n        target_price = numeric(),\n        stop_loss = numeric(),\n        entry_criteria = character(),\n        scan_source = character(),\n        notes = character(),\n        status = character(),\n        pnl = numeric(),\n        pnl_percent = numeric(),\n        created_at = as.POSIXct(character()),\n        updated_at = as.POSIXct(character())\n      ))\n    })\n  })\n  \n  # Load and process data\n  scan_data <- reactive({\n    # Replace this with your actual data loading\n    create_sample_data()\n  })\n  \n  # Update choice inputs based on data\n  observe({\n    data <- scan_data()\n    scan_types <- unique(data$scan_symbol)\n    symbols <- unique(data$symbol)\n    \n    updateSelectInput(session, \"freq_scan_type\", choices = scan_types)\n    updateSelectInput(session, \"hist_scan_type\", choices = scan_types)\n    updateSelectInput(session, \"alert_symbols\", choices = symbols)\n    updateSelectInput(session, \"alert_scan_types\", choices = scan_types)\n  })\n  \n  # Tab 1: Scan Frequency Analysis\n  freq_data <- eventReactive(input$freq_update, {\n    data <- scan_data()\n    \n    # Filter data\n    if (!is.null(input$freq_date_range)) {\n      data <- data[scan_date >= input$freq_date_range[1] & \n                     scan_date <= input$freq_date_range[2]]\n    }\n    \n    if (!is.null(input$freq_scan_type) && length(input$freq_scan_type) > 0) {\n      data <- data[scan_symbol %in% input$freq_scan_type]\n    }\n    \n    \n    unique_dates <- sort(unique(data$scan_date), decreasing = TRUE)\n    current_date <- unique_dates[1]\n    prior_date <- unique_dates[2]\n    \n    print(prior_date,current_date)\n    \n    freq_summary <- data[, .(\n      prior_date_count = sum(scan_date == prior_date),\n      current_date_count = sum(scan_date == current_date),\n      #appearances = .N,\n      #scan_types = length(unique(scan_symbol)),\n      scan_types = length(unique(scan_symbol[scan_date == current_date])),\n      #min_scan_date = min(scan_date),\n      #max_scan_date = max(scan_date),\n      first_seen = min(scan_date),\n      last_seen = max(scan_date)\n    ), by = symbol][current_date_count >= input$freq_min_appearances][order(-(current_date_count-prior_date_count))]\n    \n    return(freq_summary)\n    \n    # Calculate frequency\n    # freq_summary <- data[, .(\n    #   appearances = .N,\n    #   scan_types = length(unique(scan_symbol)),\n    #   first_seen = min(scan_date),\n    #   last_seen = max(scan_date)\n    # ), by = symbol][appearances >= input$freq_min_appearances][order(-appearances)]\n    # \n    # return(freq_summary)\n  })\n  \n  output$freq_plot <- renderPlot({\n    data <- freq_data()\n    if (nrow(data) > 0) {\n      top_20 <- head(data, 20)\n      barplot(top_20$current_date_count, names.arg = top_20$symbol,\n              las = 2, main = \"Top 20 Symbols by Scan Frequency\",\n              col = \"steelblue\", ylab = \"Number of Appearances\")\n    }\n  })\n  \n  output$freq_table <- DT::renderDataTable({\n    DT::datatable(freq_data(), options = list(pageLength = 15))\n  })\n  \n  # Tab 2: Scan Pattern Analysis\n  pattern_data <- eventReactive(input$pattern_update, {\n    data <- scan_data()\n    \n    if (!is.null(input$pattern_date_range)) {\n      data <- data[scan_date >= input$pattern_date_range[1] & \n                     scan_date <= input$pattern_date_range[2]]\n    }\n    \n    # Create weekly summary\n    data[, week := format(as.Date(scan_date), \"%Y-%W\")]\n    #data[, week :=paste0(strftime(as.Date(scan_date), format = \"%Y\"),\"-\",strftime(as.Date(scan_date), format = \"%V\"))]\n    pattern_summary <- data[, .N, by = .(week, scan_symbol)]\n    \n    return(pattern_summary)\n  })\n  \n  output$pattern_plot <- renderPlot({\n    data <- pattern_data()\n    if (nrow(data) > 0) {\n      if (input$pattern_view == \"heatmap\") {\n        # Simple heatmap using base R\n        pivot_data <- dcast(data, week ~ scan_symbol, value.var = \"N\", fill = 0)\n        mat <- as.matrix(pivot_data[, -1])\n        rownames(mat) <- pivot_data$week\n        heatmap(mat, main = \"Scan Activity Heatmap\", scale = \"column\")\n      } else if (input$pattern_view == \"timeseries\") {\n        \n        data <- scan_data()\n        \n        if (!is.null(input$pattern_date_range)) {\n          data <- data[scan_date >= input$pattern_date_range[1] & \n                         scan_date <= input$pattern_date_range[2]]\n        }\n        # Time series plot\n        # weekly_totals <- data[, sum(N), by = week]\n        # plot(1:nrow(weekly_totals), weekly_totals$V1, type = \"l\",\n        #      main = \"Weekly Scan Activity\", xlab = \"Week\", ylab = \"Total Scans\")\n        # First aggregate the data to get counts by scan_symbol and date\n        # Using the correct column names from your data\n        plot_data <- data[, .(symbol_count = .N), by = .(scan_symbol, scan_date)]\n        \n        # Convert scan_date to Date format\n        plot_data$scan_date <- as.Date(plot_data$scan_date)\n        \n        # Get unique scan symbols and dates for plotting\n        scan_symbols <- unique(plot_data$scan_symbol)\n        dates <- sort(unique(plot_data$scan_date))\n        \n        # Set up colors for different scan symbols\n        colors <- rainbow(length(scan_symbols))\n        names(colors) <- scan_symbols\n        \n        # Create the base plot\n        plot(range(dates), range(plot_data$symbol_count), \n             type = \"n\",\n             xlab = \"Date\", \n             ylab = \"Number of Symbols\",\n             main = \"Time Series of Symbol Counts by Scan Type\",\n             xaxt = \"n\")\n        \n        # Add x-axis with formatted dates\n        axis.Date(1, at = dates, format = \"%m-%d\", las = 2)\n        \n        # Plot lines for each scan_symbol\n        for(i in 1:length(scan_symbols)) {\n          scan_data <- plot_data[scan_symbol == scan_symbols[i]]\n          lines(scan_data$scan_date, scan_data$symbol_count, \n                col = colors[i], lwd = 2, type = \"o\", pch = 16)\n        }\n        \n        # Add legend\n        legend(\"topright\", \n               legend = scan_symbols,\n               col = colors,\n               lwd = 2,\n               pch = 16,\n               bty = \"n\")\n        \n        \n      }\n      else{\n        data <- scan_data()\n        \n        if (!is.null(input$pattern_date_range)) {\n          data <- data[scan_date >= input$pattern_date_range[1] & \n                         scan_date <= input$pattern_date_range[2]]\n        }\n        # Get the last 5 unique dates\n        last_5_dates <- sort(unique(data$scan_date), decreasing = TRUE)[1:5]\n        \n        # Count total symbols for each of the last 5 dates\n        date_counts <- data[scan_date %in% last_5_dates, .(total_symbols = .N), by = scan_date]\n        \n        # Sort by date for proper ordering\n        date_counts <- date_counts[order(scan_date)]\n        \n        # Create bar plot\n        barplot(date_counts$total_symbols,\n                names.arg = format(as.Date(date_counts$scan_date), \"%m-%d\"),\n                main = \"Total Symbol Counts by Last 5 Dates\",\n                xlab = \"Date\",\n                ylab = \"Total Number of Symbols\",\n                col = \"steelblue\",\n                border = \"white\",\n                las = 2,\n                ylim = c(0, max(date_counts$total_symbols) * 1.1))\n        \n        # Add value labels on top of bars\n        text(x = 1:nrow(date_counts), \n             y = date_counts$total_symbols + max(date_counts$total_symbols) * 0.02,\n             labels = date_counts$total_symbols,\n             pos = 3,\n             cex = 0.8)\n        \n        # Add grid for better readability\n        grid(nx = NA, ny = NULL, col = \"lightgray\", lty = \"dotted\")\n      }\n    }\n  })\n  \n  output$pattern_summary <- DT::renderDataTable({\n    data <- scan_data()\n    if (!is.null(input$pattern_date_range)) {\n      data <- data[scan_date >= input$pattern_date_range[1] & \n                     scan_date <= input$pattern_date_range[2]]\n    }\n    # summary_table <- data[, .(total_scans = .N), by = .(scan_date,scan_symbol)]\n    # DT::datatable(summary_table, options = list(pageLength = 10))\n    \n    recent_dates <- sort(unique(data$scan_date), decreasing = TRUE)[1:4]\n    \n    # Create a summary table with counts by scan_symbol for each of the 4 dates\n    result <- data[scan_date %in% recent_dates, \n                   .(count = .N), \n                   by = .(scan_symbol, scan_date)]\n    \n    # Reshape to wide format with dates as columns\n    library(data.table)\n    wide_result <- dcast(result, scan_symbol ~ scan_date, value.var = \"count\", fill = 0)\n    \n    # Reorder columns by date (most recent first)\n    date_cols <- as.character(sort(recent_dates, decreasing = FALSE))\n    wide_result <- wide_result[, c(\"scan_symbol\", date_cols), with = FALSE]\n    \n    # Add a total column\n    #wide_result[, total := rowSums(.SD), .SDcols = date_cols]\n    \n    # Display the result\n    DT::datatable(wide_result, options = list(pageLength = 10))\n  })\n  \n  # Tab 3: Momentum Tracker\n  momentum_data <- eventReactive(input$momentum_update, {\n    data <- scan_data()\n    weeks_back <- input$momentum_weeks\n    # \n    # # Calculate recent vs historical frequency\n    # recent_date <- Sys.Date() - (weeks_back * 7)\n    \n    # recent_freq <- data[scan_date >= recent_date, .N, by = symbol]\n    # historical_freq <- data[scan_date < recent_date, .N, by = symbol]\n    \n    sorted_dates <- sort(unique(data$scan_date), decreasing = TRUE)\n    \n    # Determine which dates to use based on weeks_back parameter\n    if(exists(\"weeks_back\") && !is.null(weeks_back)) {\n      last_2_dates <- sorted_dates[c(1, weeks_back)]\n    } else {\n      last_2_dates <- sorted_dates[c(1, 2)]\n    }\n    \n    # Check if we got 2 dates, if not fall back to c(1,2)\n    if(length(last_2_dates) != 2) {\n      last_2_dates <- sorted_dates[c(1, 2)]\n    }\n    \n    \n    #last_2_dates <- sort(unique(data$scan_date), decreasing = TRUE)[c(1,weeks_back)]\n    most_recent_date <- last_2_dates[1]\n    second_recent_date <- last_2_dates[2]\n    \n    # Get frequency for most recent date\n    recent_freq <- data[scan_date == most_recent_date, .N, by = symbol]\n    \n    # Get frequency for the comparison date\n    historical_freq <- data[scan_date == second_recent_date, .N, by = symbol]\n    \n    momentum <- merge(recent_freq, historical_freq, by = \"symbol\", all = TRUE)\n    momentum[is.na(N.x), N.x := 0]\n    momentum[is.na(N.y), N.y := 0]\n    \n    #momentum[, momentum_score := round(ifelse(N.y > 0, (N.x / N.y) * 100, N.x * 100),2)]\n    #momentum[, momentum_type := ifelse(momentum_score > 100, \"Heating Up\", \"Cooling Down\")]\n    \n    # Combined momentum score logic\n    momentum[, `:=`(\n      # Base momentum score (your original logic)\n      momentum_score = round(ifelse(N.y > 0, (N.x / N.y) * 100, N.x * 100), 2),\n      \n      # Calculate additional metrics for sophisticated scoring\n      freq_change = N.x - N.y,\n      freq_change_pct = round(ifelse(N.y > 0, ((N.x - N.y) / N.y) * 100, \n                                     ifelse(N.x > 0, 100, 0)), 2),\n      activity_ratio = round(ifelse(N.y > 0, N.x / N.y, \n                                    ifelse(N.x > 0, Inf, 0)), 2)\n    )]\n    \n    # Sophisticated momentum classification with multiple criteria\n    momentum[, momentum_type := case_when(\n      # Strong heating up: high momentum score AND significant increase\n      momentum_score >= 200 & freq_change >= 2 ~ \"Heating Up\",\n      \n      # Moderate heating up: above baseline with positive change\n      momentum_score >= 120 & freq_change > 0 ~ \"Heating Up\",\n      \n      # New emergence: high recent activity with little/no historical\n      momentum_score >= 150 & N.y <= 1 ~ \"Heating Up\",\n      \n      # Strong cooling down: low momentum score AND significant decrease\n      momentum_score <= 50 & freq_change <= -2 ~ \"Cooling Down\",\n      \n      # Moderate cooling down: below baseline with negative change\n      momentum_score <= 80 & freq_change < 0 ~ \"Cooling Down\",\n      \n      # Disappearing: little recent activity with high historical\n      momentum_score <= 25 & N.y >= 3 ~ \"Cooling Down\",\n      \n      # Default: neutral/stable\n      TRUE ~ \"Neutral\"\n    )]\n    \n    # Add momentum strength for further analysis\n    momentum[, momentum_strength := case_when(\n      momentum_type == \"Heating Up\" & momentum_score >= 300 ~ \"Very Strong\",\n      momentum_type == \"Heating Up\" & momentum_score >= 200 ~ \"Strong\", \n      momentum_type == \"Heating Up\" & momentum_score >= 120 ~ \"Moderate\",\n      momentum_type == \"Cooling Down\" & momentum_score <= 25 ~ \"Very Strong\",\n      momentum_type == \"Cooling Down\" & momentum_score <= 50 ~ \"Strong\",\n      momentum_type == \"Cooling Down\" & momentum_score <= 80 ~ \"Moderate\",\n      TRUE ~ \"Weak\"\n    )]\n    \n    # Sort by momentum type and strength\n    momentum <- momentum[order(momentum_type, -momentum_score)]\n    \n    setnames(momentum, c(\"N.x\", \"N.y\"), c(\"recent_freq\", \"historical_freq\"))\n    \n    return(momentum[order(-momentum_score)])\n  })\n  \n  output$momentum_plot <- renderPlot({\n    data <- momentum_data()\n    if (input$momentum_type==\"Heating Up\" | input$momentum_type == \"Cooling Down\")\n    \n    if (input$momentum_type==\"Heating Up\")\n    {\n      data <- data[momentum_type==input$momentum_type,][order(momentum_type, -freq_change)]\n    }\n    \n    else if (input$momentum_type == \"Cooling Down\")\n    {\n      data <- data[momentum_type==input$momentum_type,][order(momentum_type, freq_change)]\n    }\n    \n    if (nrow(data) > 0) {\n      top_20 <- head(data, 20)\n      colors <- ifelse(top_20$momentum_score > 100, \"maroon\", \"lightblue\")\n      barplot(top_20$momentum_score, names.arg = top_20$symbol,\n              las = 2, main = \"Symbol Momentum Score\", col = colors,\n              ylab = \"Momentum Score (%)\")\n      abline(h = 100, lty = 2, col = \"black\")\n    }\n  })\n  \n  output$momentum_table <- DT::renderDataTable({\n    data <- momentum_data()\n    if (input$momentum_type==\"Heating Up\")\n    {\n      data <- data[momentum_type==input$momentum_type,][order(momentum_type, -freq_change)]\n    }\n    \n    else if (input$momentum_type == \"Cooling Down\")\n    {\n      data <- data[momentum_type==input$momentum_type,][order(momentum_type, freq_change)]\n    }\n    \n    DT::datatable(data, options = list(pageLength = 15))\n  })\n  \n  output$hot_symbols <- renderText({\n    data <- momentum_data()\n    if (input$momentum_type==\"Heating Up\" | input$momentum_type == \"Cooling Down\")\n    {\n      data <- data[momentum_type==input$momentum_type,]\n    }\n    \n    if (input$momentum_type==\"Heating Up\" )\n    {\n      hot <- data[order(momentum_type, -momentum_score)] #[momentum_score > input$momentum_threshold]\n    if (nrow(hot) > 0) {\n      paste(\"Hot Symbols:\", paste(head(hot$symbol, 10), collapse = \", \"))\n    } \n    }\n    else if (input$momentum_type==\"Cooling Down\" )\n    {\n      cool <- data[order(freq_change)]\n      if (nrow(cool) > 0) {\n        paste(\"Cool Symbols:\", paste(head(cool$symbol, 10), collapse = \", \"))\n      } \n    }\n    \n    else {\n      \"No symbols above threshold\"\n    }\n  })\n  \n  # Tab 4: Correlation Analysis\n  corr_data <- eventReactive(input$corr_update, {\n    data <- scan_data()\n    \n    if (!is.null(input$corr_date_range)) {\n      data <- data[scan_date >= input$corr_date_range[1] & \n                     scan_date <= input$corr_date_range[2]]\n    }\n    \n    # Filter symbols with minimum frequency\n    symbol_freq <- data[, .N, by = symbol][N >= input$corr_min_freq]\n    data <- data[symbol %in% symbol_freq$symbol]\n    \n    # Create scan type co-occurrence matrix\n    symbol_scans <- data[, .(scan_types = list(unique(scan_symbol))), by = symbol]\n    \n    return(symbol_scans)\n  })\n  \n  output$correlation_heatmap <- renderPlot({\n    # Placeholder for correlation heatmap\n    plot(1:10, 1:10, main = \"Scan Type Correlation Matrix\", \n         xlab = \"Scan Type\", ylab = \"Scan Type\")\n    text(5, 5, \"Correlation analysis\\nwould be displayed here\", cex = 1.5)\n  })\n  \n  output$correlation_table <- DT::renderDataTable({\n    data.frame(\n      Scan_Type_1 = c(\"CarusoInsights\", \"roc_mdt25\"),\n      Scan_Type_2 = c(\"roc_mdt25\", \"CarusoInsights\"),\n      Correlation = c(0.75, 0.75),\n      P_Value = c(0.001, 0.001)\n    )\n  })\n  \n  # Tab 5: Portfolio Screening\n  portfolio_data <- eventReactive(input$portfolio_analyze, {\n    data <- scan_data()\n\n    symbols <- trimws(unlist(strsplit(input$portfolio_symbols, \"\\n\")))\n    symbols <- symbols[symbols != \"\"]\n    \n    if (!is.null(input$portfolio_date_range)) {\n      data <- data[scan_date >= input$portfolio_date_range[1] & \n                     scan_date <= input$portfolio_date_range[2]]\n    }\n    \n    portfolio_scans <- data[symbol %in% symbols]\n    return(list(data = portfolio_scans, symbols = symbols))\n  })\n  \n  output$portfolio_plot <- renderPlot({\n    port_data <- portfolio_data()$data\n    if (nrow(port_data) > 0) {\n      # symbol_counts <- port_data[, .N, by = symbol]\n      # barplot(symbol_counts$N, names.arg = symbol_counts$symbol,\n      #         main = \"Portfolio Scan Activity\", col = \"darkgreen\",\n      #         ylab = \"Number of Scans\")\n      \n      # Get the last 2 unique dates\n      last_2_dates <- sort(unique(port_data$scan_date), decreasing = TRUE)[1:2]\n      current_date <- last_2_dates[1]\n      last_date <- last_2_dates[2]\n      \n      # Get counts for both dates by symbol\n      current_counts <- port_data[scan_date == current_date, .N, by = symbol]\n      last_counts <- port_data[scan_date == last_date, .N, by = symbol]\n      \n      # Merge the counts to ensure we have all symbols\n      setnames(current_counts, \"N\", \"current_count\")\n      setnames(last_counts, \"N\", \"last_count\")\n      \n      # Full outer join to get all symbols from both dates\n      all_symbols <- merge(current_counts, last_counts, by = \"symbol\", all = TRUE)\n      \n      # Replace NA values with 0\n      all_symbols[is.na(current_count), current_count := 0]\n      all_symbols[is.na(last_count), last_count := 0]\n      \n      # Create matrix for grouped bar plot\n      count_matrix <- as.matrix(t(all_symbols[, .(last_count, current_count)]))\n      colnames(count_matrix) <- all_symbols$symbol\n      \n      # Create grouped bar plot\n      barplot(count_matrix,\n              main = \"Portfolio Scan Activity - Last vs Current Date\",\n              ylab = \"Number of Scans\",\n              col = c(\"lightblue\", \"darkgreen\"),\n              beside = TRUE,\n              legend.text = c(paste(\"Last Date:\", format(as.Date(last_date), \"%m-%d\")),\n                              paste(\"Current Date:\", format(as.Date(current_date), \"%m-%d\"))),\n              args.legend = list(x = \"topright\"),\n              las = 2,\n              cex.names = 0.8)\n      \n      # Add grid for better readability\n      grid(nx = NA, ny = NULL, col = \"lightgray\", lty = \"dotted\")\n    }\n  })\n  \n  \n  output$portfolio_plot2 <- renderPlot({\n    port_data <- portfolio_data()$data\n    if (nrow(port_data) > 0) {\n      # ===== CREATIVE IDEA 5: PORTFOLIO RADAR CHART =====\n      # Create radar chart data for top symbols\n      library(fmsb)\n      top_symbols <- port_data[, .N, by = symbol][order(-N)][1:min(6, .N)]$symbol\n      \n      radar_data <- port_data[symbol %in% top_symbols, {\n        dates <- sort(unique(scan_date))\n        list(\n          Volume = .N,\n          Diversity = length(unique(scan_symbol)),\n          Recency = as.numeric(max(scan_date) - min(port_data$scan_date)) + 1,\n          Consistency = length(unique(scan_date)),\n          Momentum = ifelse(length(dates) >= 2, \n                            sum(scan_date == dates[length(dates)]), 1)\n        )\n      }, by = symbol]\n      \n      # Normalize for radar chart (0-100 scale)\n      radar_matrix <- as.data.frame(radar_data[, -1])\n      radar_matrix[] <- lapply(radar_matrix, function(x) (x/max(x, na.rm=TRUE))*100)\n      rownames(radar_matrix) <- radar_data$symbol\n      \n      # Add max and min rows for radar chart\n      radar_final <- rbind(rep(100, ncol(radar_matrix)), \n                           rep(0, ncol(radar_matrix)), \n                           radar_matrix)\n      \n      radarchart(radar_final, \n                 title = \"Portfolio Multi-Dimensional Analysis\")\n    }\n  })\n  \n  # output$portfolio_plot2 <- renderPlot({\n  #   port_data <- portfolio_data()$data\n  #   if (nrow(port_data) > 0) {\n  #     # ===== CREATIVE IDEA 6: PORTFOLIO TIMELINE =====\n  #     timeline_data <- port_data[, {\n  #       list(\n  #         event_type = \"scan\",\n  #         event_detail = paste0(length(unique(scan_symbol)), \" scan types\"),\n  #         scan_count = .N\n  #       )\n  #     }, by = .(symbol, scan_date)]\n  #     \n  #     # Simple timeline visualization\n  #     plot(as.Date(timeline_data$scan_date), \n  #          as.numeric(as.factor(timeline_data$symbol)),\n  #          pch = 19, \n  #          cex = timeline_data$scan_count/3,\n  #          col = rainbow(length(unique(timeline_data$symbol)))[as.numeric(as.factor(timeline_data$symbol))],\n  #          main = \"Portfolio Scan Timeline\",\n  #          xlab = \"Date\", ylab = \"Symbols\",\n  #          yaxt = \"n\")\n  #     axis(2, at = 1:length(unique(timeline_data$symbol)), \n  #          labels = unique(timeline_data$symbol), las = 2)\n  #   }\n  # })\n  \n  # output$portfolio_plot2 <- renderPlot({\n  #   port_data <- portfolio_data()$data\n  #   if (nrow(port_data) > 0) {\n  #     # Get counts for all dates by symbol\n  #     symbol_date_counts <- port_data[, .N, by = .(symbol, scan_date)]\n  #     \n  #     # Get all unique symbols and dates\n  #     all_symbols <- unique(symbol_date_counts$symbol)\n  #     all_dates <- sort(unique(symbol_date_counts$scan_date))\n  #     \n  #     # Create a complete grid of all symbol-date combinations\n  #     complete_grid <- CJ(symbol = all_symbols, scan_date = all_dates)\n  #     \n  #     # Merge with actual counts and fill missing with 0\n  #     symbol_counts_complete <- merge(complete_grid, symbol_date_counts, \n  #                                     by = c(\"symbol\", \"scan_date\"), all.x = TRUE)\n  #     symbol_counts_complete[is.na(N), N := 0]\n  #     \n  #     # Reshape to wide format for plotting\n  #     library(data.table)\n  #     count_matrix_wide <- dcast(symbol_counts_complete, symbol ~ scan_date, value.var = \"N\")\n  #     \n  #     # Convert to matrix (excluding symbol column)\n  #     symbol_names <- count_matrix_wide$symbol\n  #     count_matrix <- as.matrix(count_matrix_wide[, -1])\n  #     rownames(count_matrix) <- symbol_names\n  #     \n  #     # Transpose for barplot (dates as groups, symbols as series)\n  #     count_matrix_t <- t(count_matrix)\n  #     \n  #     # Create colors for each symbol\n  #     colors <- rainbow(length(all_symbols))\n  #     \n  #     # Create grouped bar plot\n  #     barplot(count_matrix_t,\n  #             main = \"Portfolio Scan Activity - All Dates\",\n  #             ylab = \"Number of Scans\",\n  #             xlab = \"Symbols\",\n  #             col = colors,\n  #             beside = TRUE,\n  #             legend.text = format(as.Date(all_dates), \"%m-%d\"),\n  #             args.legend = list(x = \"topright\", cex = 0.7),\n  #             las = 2,\n  #             cex.names = 0.8)\n  #     \n  #     # Add grid for better readability\n  #     grid(nx = NA, ny = NULL, col = \"lightgray\", lty = \"dotted\")\n  #   }\n  # })\n  # \n  \n  # output$portfolio_table <- DT::renderDataTable({\n  #   port_data <- portfolio_data()$data\n  #   if (nrow(port_data) > 0) {\n  #     summary_table <- port_data[, .(\n  #       total_scans = .N,\n  #       scan_types = length(unique(scan_symbol)),\n  #       latest_scan = max(scan_date)\n  #     ), by = symbol]\n  #     DT::datatable(summary_table, options = list(pageLength = 10))\n  #   }\n  # })\n \n  output$portfolio_table3 <- DT::renderDataTable({\n    port_data <- portfolio_data()$data\n    if (nrow(port_data) > 0) {\n      # Get the last 2 unique dates (representing this week vs last week)\n      weekly_dates <- sort(unique(port_data$scan_date), decreasing = TRUE)[1:2]\n      this_week_date <- weekly_dates[1]\n      last_week_date <- weekly_dates[2]\n      \n      # Get scan details for this week and last week\n      this_week_scans <- port_data[scan_date == this_week_date, \n                                   .(scan_types = paste(unique(scan_symbol), collapse = \", \"),\n                                     scan_count = .N), \n                                   by = symbol]\n      setnames(this_week_scans, c(\"scan_types\", \"scan_count\"), c(\"this_week_scans\", \"this_week_count\"))\n      \n      last_week_scans <- port_data[scan_date == last_week_date, \n                                   .(scan_types = paste(unique(scan_symbol), collapse = \", \"),\n                                     scan_count = .N), \n                                   by = symbol]\n      setnames(last_week_scans, c(\"scan_types\", \"scan_count\"), c(\"last_week_scans\", \"last_week_count\"))\n      \n      # Merge the data to show side-by-side comparison\n      weekly_comparison <- merge(this_week_scans, last_week_scans, by = \"symbol\", all = TRUE)\n      \n      # Replace NA values with appropriate defaults\n      weekly_comparison[is.na(this_week_scans), this_week_scans := \"None\"]\n      weekly_comparison[is.na(last_week_scans), last_week_scans := \"None\"]\n      weekly_comparison[is.na(this_week_count), this_week_count := 0]\n      weekly_comparison[is.na(last_week_count), last_week_count := 0]\n      \n      # Add comparison metrics\n      weekly_comparison[, `:=`(\n        change = this_week_count - last_week_count,\n        status = case_when(\n          this_week_count > last_week_count ~ \"ðŸ“ˆ Increased\",\n          this_week_count < last_week_count ~ \"ðŸ“‰ Decreased\", \n          this_week_count == last_week_count & this_week_count > 0 ~ \"âž¡ï¸ Same\",\n          this_week_count == 0 & last_week_count == 0 ~ \"âŒ No Activity\",\n          this_week_count > 0 & last_week_count == 0 ~ \"ðŸ†• New Entry\",\n          this_week_count == 0 & last_week_count > 0 ~ \"ðŸš« Dropped Out\"\n        ),\n        new_scans = \"\",\n        dropped_scans = \"\"\n      )]\n      \n      # Identify new and dropped scan types\n      for(i in 1:nrow(weekly_comparison)) {\n        this_week_types <- if(weekly_comparison$this_week_scans[i] != \"None\") {\n          trimws(strsplit(weekly_comparison$this_week_scans[i], \",\")[[1]])\n        } else { character(0) }\n        \n        last_week_types <- if(weekly_comparison$last_week_scans[i] != \"None\") {\n          trimws(strsplit(weekly_comparison$last_week_scans[i], \",\")[[1]])\n        } else { character(0) }\n        \n        new_types <- setdiff(this_week_types, last_week_types)\n        dropped_types <- setdiff(last_week_types, this_week_types)\n        \n        weekly_comparison$new_scans[i] <- if(length(new_types) > 0) paste(new_types, collapse = \", \") else \"\"\n        weekly_comparison$dropped_scans[i] <- if(length(dropped_types) > 0) paste(dropped_types, collapse = \", \") else \"\"\n      }\n      \n      # Reorder columns for better presentation\n      setcolorder(weekly_comparison, c(\"symbol\", \"status\", \"change\", \n                                       \"this_week_count\", \"this_week_scans\",\n                                       \"last_week_count\", \"last_week_scans\", \n                                       \"new_scans\", \"dropped_scans\"))\n      \n      # Create enhanced datatable\n      library(DT)\n      DT::datatable(weekly_comparison, \n                    options = list(\n                      pageLength = 15, \n                      dom = 'Bfrtip',\n                      scrollX = TRUE,\n                      columnDefs = list(\n                        list(width = '100px', targets = c(0, 1, 2, 3, 5)),\n                        list(width = '200px', targets = c(4, 6, 7, 8))\n                      )\n                    ),\n                    caption = paste0(\"ðŸ“Š Weekly Scan Comparison: \", \n                                     format(as.Date(this_week_date), \"%m/%d\"), \n                                     \" vs \", \n                                     format(as.Date(last_week_date), \"%m/%d\")))  %>%\n        DT::formatStyle('status',\n                        backgroundColor = DT::styleEqual(\n                          c('ðŸ“ˆ Increased', 'ðŸ“‰ Decreased', 'ðŸ†• New Entry', 'ðŸš« Dropped Out', 'âž¡ï¸ Same', 'âŒ No Activity'), \n                          c('#d4edda', '#f8d7da', '#cce5ff', '#ffcccc', '#f0f0f0', '#e6e6e6')\n                        )) %>%\n        DT::formatStyle('change',\n                        color = DT::styleInterval(c(-0.1, 0.1), c('red', 'black', 'green')),\n                        fontWeight = 'bold') %>%\n        DT::formatStyle('new_scans',\n                        backgroundColor = DT::styleEqual('', 'white', '#e8f5e8')) %>%\n        DT::formatStyle('dropped_scans', \n                        backgroundColor = DT::styleEqual('', 'white', '#ffe8e8'))\n      \n      # # Optional: Summary statistics\n      # cat(\"\\n=== WEEKLY SCAN SUMMARY ===\\n\")\n      # cat(\"This Week Date:\", format(as.Date(this_week_date), \"%Y-%m-%d\"), \"\\n\")\n      # cat(\"Last Week Date:\", format(as.Date(last_week_date), \"%Y-%m-%d\"), \"\\n\")\n      # cat(\"Total Symbols This Week:\", nrow(weekly_comparison[this_week_count > 0]), \"\\n\")\n      # cat(\"Total Symbols Last Week:\", nrow(weekly_comparison[last_week_count > 0]), \"\\n\")\n      # cat(\"New Entries:\", nrow(weekly_comparison[status == \"ðŸ†• New Entry\"]), \"\\n\")\n      # cat(\"Dropped Out:\", nrow(weekly_comparison[status == \"ðŸš« Dropped Out\"]), \"\\n\")\n      # cat(\"Increased Activity:\", nrow(weekly_comparison[status == \"ðŸ“ˆ Increased\"]), \"\\n\")\n      # cat(\"Decreased Activity:\", nrow(weekly_comparison[status == \"ðŸ“‰ Decreased\"]), \"\\n\")\n    }\n  })\n  \n  output$portfolio_table <- DT::renderDataTable({\n    port_data <- portfolio_data()$data\n    if (nrow(port_data) > 0) {\n      # ===== CREATIVE IDEA 1: PORTFOLIO HEATMAP =====\n      # Show scan intensity over time with color coding\n      heatmap_data <- port_data[, .N, by = .(symbol, scan_date)]\n      heatmap_matrix <- dcast(heatmap_data, symbol ~ scan_date, value.var = \"N\", fill = 0)\n      heatmap_matrix_only <- as.matrix(heatmap_matrix[, -1])\n      rownames(heatmap_matrix_only) <- heatmap_matrix$symbol\n      \n      # Create heatmap\n      heatmap(heatmap_matrix_only, \n              main = \"Portfolio Scan Intensity Heatmap\",\n              xlab = \"Dates\", ylab = \"Symbols\",\n              col = colorRampPalette(c(\"white\", \"yellow\", \"red\"))(50))\n      \n      # ===== CREATIVE IDEA 2: PORTFOLIO MOMENTUM DASHBOARD =====\n      momentum_analysis <- port_data[, {\n        dates <- sort(unique(scan_date))\n        if(length(dates) >= 2) {\n          recent_count <- sum(scan_date == dates[length(dates)])\n          prev_count <- sum(scan_date == dates[length(dates)-1])\n          momentum_score <- ifelse(prev_count > 0, (recent_count/prev_count)*100, recent_count*100)\n          trend <- ifelse(momentum_score > 120, \"ðŸ”¥ Hot\", \n                          ifelse(momentum_score < 80, \"â„ï¸ Cooling\", \"âž¡ï¸ Stable\"))\n        } else {\n          momentum_score <- 100\n          trend <- \"âž¡ï¸ New\"\n        }\n        \n        list(\n          total_scans = .N,\n          unique_scan_types = length(unique(scan_symbol)),\n          momentum_score = round(momentum_score, 1),\n          trend = trend,\n          scan_frequency = round(.N / length(unique(scan_date)), 1),\n          latest_scan = max(scan_date),\n          scan_consistency = round(length(unique(scan_date)) / max(length(unique(port_data$scan_date))), 2)\n        )\n      }, by = symbol]\n      \n      DT::datatable(momentum_analysis, \n                    options = list(pageLength = 15, dom = 'Bfrtip'),\n                    caption = \"ðŸš€ Portfolio Momentum Dashboard\") %>%\n        DT::formatStyle('trend',\n                        backgroundColor = DT::styleEqual(c('ðŸ”¥ Hot', 'â„ï¸ Cooling', 'âž¡ï¸ Stable'), \n                                                         c('#ffcccc', '#ccddff', '#f0f0f0')))\n      \n    }\n  })\n  \n  \n  output$portfolio_table2 <- DT::renderDataTable({\n    port_data <- portfolio_data()$data\n    if (nrow(port_data) > 0) {\n      pattern_analysis <- port_data[, {\n        scan_dates <- sort(unique(scan_date))\n        scan_types <- unique(scan_symbol)\n        \n        # Calculate scan patterns\n        avg_gap <- if(length(scan_dates) > 1) {\n          mean(diff(as.Date(scan_dates)))\n        } else { NA }\n        \n        # Scan diversity score\n        diversity_score <- length(scan_types) / length(unique(port_data$scan_symbol)) * 100\n        \n        # Recent activity (last 7 days equivalent)\n        recent_dates <- tail(sort(unique(port_data$scan_date)), 3)\n        recent_activity <- sum(scan_date %in% recent_dates)\n        \n        list(\n          total_activity = .N,\n          scan_diversity = paste0(round(diversity_score, 1), \"%\"),\n          avg_scan_gap = round(avg_gap, 1),\n          recent_activity = recent_activity,\n          scan_pattern = case_when(\n            avg_gap <= 1 ~ \"âš¡ High Frequency\",\n            avg_gap <= 3 ~ \"ðŸ”„ Regular\",\n            avg_gap <= 7 ~ \"ðŸ“… Weekly\",\n            TRUE ~ \"ðŸŒ Sporadic\"\n          ),\n          first_seen = min(scan_date),\n          latest_scan = max(scan_date)\n        )\n      }, by = symbol]      \n    }\n  })\n  \n  \n  \n  \n  output$portfolio_metrics <- renderText({\n    port_data <- portfolio_data()\n    symbols <- port_data$symbols\n    scans <- port_data$data\n    \n    coverage <- length(unique(scans$symbol)) / length(symbols) * 100\n    avg_scans <- nrow(scans) / length(symbols)\n    \n    paste0(\"Portfolio Coverage: \", round(coverage, 1), \"%\\n\",\n           \"Average Scans per Symbol: \", round(avg_scans, 1), \"\\n\",\n           \"Total Portfolio Scans: \", nrow(scans))\n  })\n  \n  # Tab 6: Signal Strength Calculator\n  output$weight_inputs <- renderUI({\n    data <- scan_data()\n    scan_types <- unique(data$scan_symbol)\n    \n    weight_inputs <- lapply(scan_types, function(scan_type) {\n      numericInput(paste0(\"weight_\", scan_type), \n                   paste(\"Weight for\", scan_type, \":\"),\n                   value = 1, min = 0, max = 10, step = 0.1)\n    })\n    \n    do.call(tagList, weight_inputs)\n  })\n  \n  signal_data <- eventReactive(input$signal_calculate, {\n    data <- scan_data()\n    scan_types <- unique(data$scan_symbol)\n    \n    # Get weights from inputs\n    weights <- sapply(scan_types, function(st) {\n      weight_input <- paste0(\"weight_\", st)\n      if (!is.null(input[[weight_input]])) {\n        input[[weight_input]]\n      } else {\n        1\n      }\n    })\n    \n    # Calculate weighted scores\n    symbol_scores <- data[, .(\n      weighted_score = sum(weights[scan_symbol]),\n      total_scans = .N\n    ), by = symbol][order(-weighted_score)]\n    \n    return(symbol_scores)\n  })\n  \n  output$signal_plot <- renderPlot({\n    data <- signal_data()\n    if (nrow(data) > 0) {\n      top_20 <- head(data, 20)\n      barplot(top_20$weighted_score, names.arg = top_20$symbol,\n              las = 2, main = \"Signal Strength Scores\", col = \"purple\",\n              ylab = \"Weighted Score\")\n    }\n  })\n  \n  output$signal_table <- DT::renderDataTable({\n    data <- signal_data()\n    strong_signals <- data[weighted_score >= input$signal_min_score]\n    DT::datatable(strong_signals, options = list(pageLength = 15))\n  })\n  \n  # Tab 7: Historical Analysis\n  output$historical_plot <- renderPlot({\n    plot(1:10, rnorm(10), main = \"Historical Scan Performance Analysis\",\n         xlab = \"Time\", ylab = \"Performance Metric\")\n    text(5, 0, \"Historical performance\\nanalysis would be\\ndisplayed here\", cex = 1.2)\n  })\n  \n  output$historical_table <- DT::renderDataTable({\n    data.frame(\n      Scan_Type = c(\"CarusoInsights\", \"roc_mdt25\"),\n      Success_Rate = c(\"75%\", \"68%\"),\n      Avg_Days_to_Move = c(3.2, 4.1),\n      Best_Performance = c(\"15%\", \"12%\")\n    )\n  })\n  \n  # Alert data processing\n  alert_data <- eventReactive(input$alert_setup, {\n    data <- scan_data()\n    alerts <- data.table()\n    \n    # Recent data (last 7 days for alerts)\n    recent_data <- data[scan_date >= (Sys.Date() - 7)]\n    \n    # Alert 1: Frequency threshold alerts\n    if (!is.null(input$alert_symbols) && length(input$alert_symbols) > 0) {\n      symbol_freq <- recent_data[symbol %in% input$alert_symbols, .N, by = symbol]\n      freq_alerts <- symbol_freq[N >= input$alert_frequency_threshold]\n      \n      if (nrow(freq_alerts) > 0) {\n        freq_alert_data <- data.table(\n          timestamp = Sys.time(),\n          symbol = freq_alerts$symbol,\n          alert_type = \"Frequency Threshold\",\n          details = paste(\"Appeared\", freq_alerts$N, \"times this week\"),\n          scan_count = freq_alerts$N,\n          priority = ifelse(freq_alerts$N >= input$alert_frequency_threshold * 2, \"High\", \"Medium\")\n        )\n        alerts <- rbind(alerts, freq_alert_data)\n      }\n    }\n    \n    # Alert 2: New symbols appearing in watched scan types\n    if (!is.null(input$alert_scan_types) && length(input$alert_scan_types) > 0) {\n      # Get symbols from last week vs previous weeks\n      last_week <- recent_data[scan_symbol %in% input$alert_scan_types]\n      previous_data <- data[scan_date < (Sys.Date() - 7) & scan_date >= (Sys.Date() - 30)]\n      previous_symbols <- unique(previous_data[scan_symbol %in% input$alert_scan_types]$symbol)\n      \n      new_symbols <- setdiff(unique(last_week$symbol), previous_symbols)\n      \n      if (length(new_symbols) > 0) {\n        new_symbol_alerts <- data.table(\n          timestamp = Sys.time(),\n          symbol = new_symbols,\n          alert_type = \"New Symbol\",\n          details = paste(\"First appearance in\", paste(input$alert_scan_types, collapse = \"/\")),\n          scan_count = sapply(new_symbols, function(s) sum(last_week$symbol == s)),\n          priority = \"High\"\n        )\n        alerts <- rbind(alerts, new_symbol_alerts)\n      }\n    }\n    \n    # Alert 3: Unusual activity (symbols with 3x normal frequency)\n    if (input$alert_new_symbols) {\n      # Calculate normal frequency (last 30 days average)\n      normal_period <- data[scan_date >= (Sys.Date() - 30) & scan_date < (Sys.Date() - 7)]\n      recent_period <- data[scan_date >= (Sys.Date() - 7)]\n      \n      if (nrow(normal_period) > 0 && nrow(recent_period) > 0) {\n        normal_freq <- normal_period[, .(avg_weekly = .N / 3), by = symbol]  # 3 weeks average\n        recent_freq <- recent_period[, .N, by = symbol]\n        \n        activity_comparison <- merge(recent_freq, normal_freq, by = \"symbol\", all.x = TRUE)\n        activity_comparison[is.na(avg_weekly), avg_weekly := 0.5]  # New symbols get low baseline\n        activity_comparison[, activity_ratio := N / avg_weekly]\n        \n        unusual_activity <- activity_comparison[activity_ratio >= 3 & N >= 2]\n        \n        if (nrow(unusual_activity) > 0) {\n          activity_alerts <- data.table(\n            timestamp = Sys.time(),\n            symbol = unusual_activity$symbol,\n            alert_type = \"Unusual Activity\",\n            details = paste(\"Activity\", round(unusual_activity$activity_ratio, 1), \"x normal\"),\n            scan_count = unusual_activity$N,\n            priority = ifelse(unusual_activity$activity_ratio >= 5, \"High\", \"Medium\")\n          )\n          alerts <- rbind(alerts, activity_alerts)\n        }\n      }\n    }\n    \n    # Sort alerts by priority and scan count\n    if (nrow(alerts) > 0) {\n      alerts[, priority_order := ifelse(priority == \"High\", 1, 2)]\n      alerts <- alerts[order(priority_order, -scan_count)]\n    }\n    \n    return(alerts)\n  })\n  \n  # Alert summary for recent activity\n  recent_alert_summary <- reactive({\n    data <- scan_data()\n    \n    # Last 24 hours activity\n    last_24h <- data[scan_date >= (Sys.Date() - 1)]\n    \n    # Last week activity  \n    last_week <- data[scan_date >= (Sys.Date() - 7)]\n    \n    # Create timeline data\n    timeline_data <- data[scan_date >= (Sys.Date() - 30)]\n    daily_counts <- timeline_data[, .N, by = scan_date][order(scan_date)]\n    \n    list(\n      last_24h = last_24h,\n      last_week = last_week,\n      timeline = daily_counts\n    )\n  })\n  \n  output$alert_table <- DT::renderDataTable({\n    alerts <- alert_data()\n    \n    if (nrow(alerts) > 0) {\n      display_alerts <- alerts[, .(\n        Timestamp = format(timestamp, \"%Y-%m-%d %H:%M\"),\n        Symbol = symbol,\n        Alert_Type = alert_type,\n        Details = details,\n        Scan_Count = scan_count,\n        Priority = priority\n      )]\n      \n      DT::datatable(display_alerts, \n                    options = list(pageLength = 15, order = list(list(5, 'desc'))),\n                    rownames = FALSE) %>%\n        DT::formatStyle('Priority',\n                        backgroundColor = DT::styleEqual(c('High', 'Medium'), \n                                                         c('#ffcccc', '#ffffcc')))\n    } else {\n      # Show recent activity when no alerts\n      data <- scan_data()\n      recent_activity <- data[scan_date >= (Sys.Date() - 7)][order(-scan_date)]\n      \n      if (nrow(recent_activity) > 0) {\n        recent_display <- recent_activity[, .(\n          Date = scan_date,\n          Symbol = symbol,\n          Scan_Type = scan_symbol,\n          Status = \"Recent Activity\"\n        )]\n        \n        DT::datatable(head(recent_display, 50), \n                      options = list(pageLength = 15),\n                      caption = \"Recent Scan Activity (No Active Alerts)\")\n      } else {\n        DT::datatable(data.frame(Message = \"No recent scan activity found\"))\n      }\n    }\n  })\n  \n  output$alert_timeline <- renderPlot({\n    summary_data <- recent_alert_summary()\n    timeline <- summary_data$timeline\n    \n    if (nrow(timeline) > 0) {\n      plot(timeline$scan_date, timeline$N, type = \"l\", \n           main = \"Daily Scan Activity (Last 30 Days)\",\n           xlab = \"Date\", ylab = \"Number of Scans\",\n           col = \"blue\", lwd = 2)\n      \n      # Add points for recent activity\n      points(timeline$scan_date, timeline$N, pch = 16, col = \"blue\")\n      \n      # Highlight last 7 days\n      recent_dates <- timeline[scan_date >= (Sys.Date() - 7)]\n      if (nrow(recent_dates) > 0) {\n        points(recent_dates$scan_date, recent_dates$N, pch = 16, col = \"red\", cex = 1.2)\n      }\n      \n      # Add trend line\n      if (nrow(timeline) > 1) {\n        trend_line <- lm(N ~ as.numeric(scan_date), data = timeline)\n        abline(trend_line, col = \"gray\", lty = 2)\n      }\n      \n      legend(\"topright\", legend = c(\"Daily Activity\", \"Last 7 Days\", \"Trend\"), \n             col = c(\"blue\", \"red\", \"gray\"), pch = c(16, 16, NA), lty = c(1, NA, 2))\n    } else {\n      plot(1, 1, type = \"n\", main = \"No Timeline Data Available\",\n           xlab = \"Date\", ylab = \"Activity\")\n      text(1, 1, \"No scan data found for timeline\", cex = 1.2)\n    }\n  })\n  \n  output$active_alerts <- renderText({\n    alerts <- alert_data()\n    summary_data <- recent_alert_summary()\n    \n    # Count different types of alerts\n    if (nrow(alerts) > 0) {\n      high_priority <- sum(alerts$priority == \"High\")\n      medium_priority <- sum(alerts$priority == \"Medium\")\n      \n      alert_summary <- paste0(\n        \"ðŸš¨ ACTIVE ALERTS:\\n\",\n        \"High Priority: \", high_priority, \"\\n\",\n        \"Medium Priority: \", medium_priority, \"\\n\",\n        \"Total Alerts: \", nrow(alerts), \"\\n\\n\"\n      )\n    } else {\n      alert_summary <- \"âœ… No Active Alerts\\n\\n\"\n    }\n    \n    # Add recent activity summary\n    recent_summary <- paste0(\n      \"ðŸ“Š RECENT ACTIVITY:\\n\",\n      \"Last 24h Scans: \", nrow(summary_data$last_24h), \"\\n\",\n      \"Last Week Scans: \", nrow(summary_data$last_week), \"\\n\",\n      \"Active Symbols: \", length(unique(summary_data$last_week$symbol)), \"\\n\",\n      \"Scan Types: \", length(unique(summary_data$last_week$scan_symbol))\n    )\n    \n    paste(alert_summary, recent_summary)\n  })\n  \n  \n  # Tab 10: Bulk Symbol Scanner Analysis\n  \n  # Parse uploaded file\n  uploaded_symbols <- reactive({\n    if (!is.null(input$bulk_upload)) {\n      file_ext <- tools::file_ext(input$bulk_upload$datapath)\n      \n      if (file_ext == \"csv\") {\n        uploaded_data <- fread(input$bulk_upload$datapath, header = FALSE)\n        symbols <- unique(trimws(unlist(uploaded_data)))\n      } else if (file_ext == \"txt\") {\n        symbols <- trimws(readLines(input$bulk_upload$datapath))\n      } else {\n        symbols <- character(0)\n      }\n      \n      return(symbols[symbols != \"\"])\n    }\n    return(NULL)\n  })\n  \n  # Update scan filter choices\n  observe({\n    data <- scan_data()\n    scan_types <- unique(data$scan_symbol)\n    updateSelectInput(session, \"bulk_scan_filter\", choices = scan_types)\n  })\n  \n  # Bulk analysis data processing\n  bulk_data <- eventReactive(input$bulk_analyze, {\n    data <- scan_data()\n    \n    # Get symbols from text input or file upload\n    text_symbols <- if (input$bulk_symbols != \"\") {\n      unique(trimws(unlist(strsplit(input$bulk_symbols, \"[,\\n\\t ]+\"))))\n    } else {\n      character(0)\n    }\n    \n    upload_symbols <- uploaded_symbols()\n    \n    all_symbols <- unique(c(text_symbols, upload_symbols))\n    all_symbols <- all_symbols[all_symbols != \"\"]\n    \n    if (length(all_symbols) == 0) {\n      return(NULL)\n    }\n    \n    # Filter by date range\n    if (!is.null(input$bulk_date_range)) {\n      data <- data[scan_date >= input$bulk_date_range[1] & \n                     scan_date <= input$bulk_date_range[2]]\n    }\n    \n    # Filter by scan types if selected\n    if (!is.null(input$bulk_scan_filter) && length(input$bulk_scan_filter) > 0) {\n      data <- data[scan_symbol %in% input$bulk_scan_filter]\n    }\n    \n    # Create comprehensive results table\n    symbol_results <- data.table(symbol = all_symbols)\n    \n    # Get scan data for each symbol\n    scan_summary <- data[symbol %in% all_symbols, .(\n      total_scans = .N,\n      scan_types = paste(unique(scan_symbol), collapse = \" | \"),\n      scan_type_count = length(unique(scan_symbol)),\n      first_seen = min(scan_date),\n      last_seen = max(scan_date),\n      days_active = as.numeric(max(scan_date) - min(scan_date)) + 1,\n      avg_scans_per_week = round(.N / (as.numeric(max(scan_date) - min(scan_date) + 1) / 7), 2)\n    ), by = symbol]\n    \n    # Merge with all requested symbols\n    results <- merge(symbol_results, scan_summary, by = \"symbol\", all.x = TRUE)\n    \n    # Fill missing values\n    results[is.na(total_scans), `:=`(\n      total_scans = 0,\n      scan_types = \"Not Found\",\n      scan_type_count = 0,\n      first_seen = as.Date(NA),\n      last_seen = as.Date(NA),\n      days_active = 0,\n      avg_scans_per_week = 0\n    )]\n    \n    # Apply minimum scans filter\n    filtered_results <- results[total_scans >= input$bulk_min_scans]\n    \n    # Create scan type matrix\n    matrix_data <- data[symbol %in% all_symbols, .N, by = .(symbol, scan_symbol)]\n    scan_matrix <- dcast(matrix_data, symbol ~ scan_symbol, value.var = \"N\", fill = 0)\n    \n    # Add symbols not found in any scans\n    missing_symbols <- setdiff(all_symbols, scan_matrix$symbol)\n    if (length(missing_symbols) > 0) {\n      scan_types <- unique(data$scan_symbol)\n      missing_matrix <- data.table(symbol = missing_symbols)\n      for (st in scan_types) {\n        missing_matrix[[st]] <- 0\n      }\n      scan_matrix <- rbind(scan_matrix, missing_matrix, fill = TRUE)\n    }\n    \n    return(list(\n      results = filtered_results,\n      all_results = results,\n      matrix = scan_matrix,\n      symbols_requested = all_symbols,\n      symbols_found = sum(results$total_scans > 0),\n      total_scans = sum(results$total_scans, na.rm = TRUE)\n    ))\n  })\n  \n  output$bulk_results_table <- DT::renderDataTable({\n    bulk_result <- bulk_data()\n    \n    if (is.null(bulk_result)) {\n      return(DT::datatable(data.frame(Message = \"Please enter symbols and click 'Run Bulk Analysis'\")))\n    }\n    \n    results_table <- bulk_result$results\n    \n    if (nrow(results_table) > 0) {\n      display_table <- results_table[, .(\n        Symbol = symbol,\n        Total_Scans = total_scans,\n        Scan_Types_Found = scan_types,\n        Unique_Scan_Types = scan_type_count,\n        First_Seen = ifelse(is.na(first_seen), \"Never\", as.character(first_seen)),\n        Last_Seen = ifelse(is.na(last_seen), \"Never\", as.character(last_seen)),\n        Days_Active = days_active,\n        Scans_Per_Week = avg_scans_per_week\n      )][order(-Total_Scans)]\n      \n      DT::datatable(display_table,\n                    options = list(pageLength = 25, scrollX = TRUE, dom = 'Bfrtip',\n                                   buttons = c('copy', 'csv', 'excel')),\n                    rownames = FALSE,\n                    extensions = 'Buttons') %>%\n        DT::formatStyle('Total_Scans',\n                        backgroundColor = DT::styleInterval(c(1, 3, 7, 15), \n                                                            c('#ffffff', '#e6ffe6', '#ccffcc', '#99ff99', '#66ff66'))) %>%\n        DT::formatStyle('Scan_Types_Found',\n                        backgroundColor = DT::styleEqual('Not Found', '#ffeeee'))\n    } else {\n      DT::datatable(data.frame(Message = \"No symbols meet the minimum scan criteria\"))\n    }\n  })\n  \n  output$bulk_matrix_table <- DT::renderDataTable({\n    bulk_result <- bulk_data()\n    \n    if (is.null(bulk_result) || is.null(bulk_result$matrix)) {\n      return(DT::datatable(data.frame(Message = \"No matrix data available\")))\n    }\n    \n    matrix_table <- bulk_result$matrix\n    \n    # Add total column\n    scan_cols <- names(matrix_table)[names(matrix_table) != \"symbol\"]\n    matrix_table[, Total := rowSums(.SD), .SDcols = scan_cols]\n    \n    # Order by total scans\n    matrix_table <- matrix_table[order(-Total)]\n    \n    DT::datatable(matrix_table,\n                  options = list(pageLength = 20, scrollX = TRUE),\n                  rownames = FALSE,\n                  caption = \"Symbol vs Scan Type Matrix (0 = Not Found, Numbers = Scan Count)\") %>%\n      DT::formatStyle(scan_cols,\n                      backgroundColor = DT::styleInterval(c(0.5, 2, 5, 10), \n                                                          c('#ffffff', '#ffffcc', '#ffccaa', '#ff9999', '#ff6666')))\n  })\n  \n  output$bulk_coverage_plot <- renderPlot({\n    bulk_result <- bulk_data()\n    \n    if (is.null(bulk_result)) {\n      plot(1, 1, type = \"n\", main = \"No Data\", xlab = \"\", ylab = \"\")\n      return()\n    }\n    \n    found_count <- bulk_result$symbols_found\n    total_count <- length(bulk_result$symbols_requested)\n    not_found <- total_count - found_count\n    \n    # Pie chart of coverage\n    pie_data <- c(found_count, not_found)\n    pie_labels <- c(paste(\"Found (\", found_count, \")\", sep = \"\"),\n                    paste(\"Not Found (\", not_found, \")\", sep = \"\"))\n    pie_colors <- c(\"#66cc66\", \"#ff6666\")\n    \n    pie(pie_data, labels = pie_labels, col = pie_colors,\n        main = paste(\"Symbol Coverage:\", round(found_count/total_count*100, 1), \"%\"))\n  })\n  \n  output$bulk_distribution_plot <- renderPlot({\n    bulk_result <- bulk_data()\n    \n    if (is.null(bulk_result)) {\n      plot(1, 1, type = \"n\", main = \"No Data\", xlab = \"\", ylab = \"\")\n      return()\n    }\n    \n    results <- bulk_result$all_results[total_scans > 0]\n    \n    if (nrow(results) > 0) {\n      # Histogram of scan frequencies\n      hist(results$total_scans, \n           breaks = max(10, min(30, length(unique(results$total_scans)))),\n           main = \"Distribution of Scan Frequencies\",\n           xlab = \"Number of Scans\", ylab = \"Number of Symbols\",\n           col = \"lightblue\", border = \"darkblue\")\n      \n      # Add mean line\n      abline(v = mean(results$total_scans), col = \"red\", lwd = 2, lty = 2)\n      text(mean(results$total_scans), max(table(results$total_scans)) * 0.8,\n           paste(\"Mean:\", round(mean(results$total_scans), 1)), pos = 4, col = \"red\")\n    }\n  })\n  \n  output$bulk_summary_stats <- renderText({\n    bulk_result <- bulk_data()\n    \n    if (is.null(bulk_result)) {\n      return(\"No analysis performed yet.\\nPlease enter symbols and click 'Run Bulk Analysis'.\")\n    }\n    \n    total_requested <- length(bulk_result$symbols_requested)\n    total_found <- bulk_result$symbols_found\n    total_scans <- bulk_result$total_scans\n    results <- bulk_result$all_results[total_scans > 0]\n    \n    stats_text <- paste0(\n      \"ðŸ“Š BULK ANALYSIS SUMMARY:\\n\",\n      \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\",\n      \"Total Symbols Analyzed: \", total_requested, \"\\n\",\n      \"Symbols Found in Scans: \", total_found, \"\\n\",\n      \"Coverage Rate: \", round(total_found/total_requested*100, 1), \"%\\n\",\n      \"Total Scan Instances: \", total_scans, \"\\n\\n\",\n      \n      \"ðŸ“ˆ ACTIVITY BREAKDOWN:\\n\",\n      \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\"\n    )\n    \n    if (nrow(results) > 0) {\n      stats_text <- paste0(stats_text,\n                           \"Average Scans per Symbol: \", round(mean(results$total_scans), 1), \"\\n\",\n                           \"Median Scans per Symbol: \", median(results$total_scans), \"\\n\",\n                           \"Most Active Symbol: \", results$symbol[which.max(results$total_scans)], \n                           \" (\", max(results$total_scans), \" scans)\\n\",\n                           \"Symbols with 1 scan: \", sum(results$total_scans == 1), \"\\n\",\n                           \"Symbols with 5+ scans: \", sum(results$total_scans >= 5), \"\\n\",\n                           \"Symbols with 10+ scans: \", sum(results$total_scans >= 10), \"\\n\\n\",\n                           \n                           \"ðŸ“… TEMPORAL ANALYSIS:\\n\",\n                           \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\",\n                           \"Average Days Active: \", round(mean(results$days_active, na.rm = TRUE), 1), \"\\n\",\n                           \"Average Scans/Week: \", round(mean(results$avg_scans_per_week, na.rm = TRUE), 2)\n      )\n    } else {\n      stats_text <- paste0(stats_text, \"No symbols found with scan activity in the selected period.\")\n    }\n    \n    return(stats_text)\n  })\n  \n  # Download handler for bulk results\n  output$bulk_download <- downloadHandler(\n    filename = function() {\n      paste(\"bulk_scan_analysis_\", Sys.Date(), \".csv\", sep = \"\")\n    },\n    content = function(file) {\n      bulk_result <- bulk_data()\n      if (!is.null(bulk_result)) {\n        write.csv(bulk_result$all_results, file, row.names = FALSE)\n      }\n    }\n  )\n  \n  # Tab 11: Trading Log System\n  \n  # Initialize trading log data storage\n  trading_log <- reactiveVal(data.table(\n    trade_id = integer(),\n    symbol = character(),\n    action = character(),\n    trade_date = as.Date(character()),\n    trade_time = as.POSIXct(character()),\n    entry_price = numeric(),\n    exit_price = numeric(),\n    quantity = integer(),\n    target_price = numeric(),\n    stop_loss = numeric(),\n    entry_criteria = character(),\n    scan_source = character(),\n    notes = character(),\n    status = character(),\n    pnl = numeric(),\n    pnl_percent = numeric(),\n    created_at = as.POSIXct(character()),\n    updated_at = as.POSIXct(character())\n  ))\n  \n  # Update symbol choices from scan data\n  observe({\n    data <- scan_data()\n    symbols <- sort(unique(data$symbol))\n    scan_types <- unique(data$scan_symbol)\n    \n    updateSelectizeInput(session, \"trade_symbol\", choices = symbols)\n    updateSelectInput(session, \"trade_scan_source\", choices = scan_types)\n    \n    # Update filter choices\n    current_log <- trading_log()\n    if (nrow(current_log) > 0) {\n      log_symbols <- sort(unique(current_log$symbol))\n      updateSelectInput(session, \"quick_symbol_filter\", choices = log_symbols)\n    }\n  })\n  \n  # Add new trade\n  observeEvent(input$add_trade, {\n    if (input$trade_symbol != \"\" && input$trade_price > 0 && input$trade_quantity > 0) {\n      current_log <- trading_log()\n      \n      new_trade <- data.table(\n        trade_id = ifelse(nrow(current_log) == 0, 1, max(current_log$trade_id) + 1),\n        symbol = input$trade_symbol,\n        action = input$trade_action,\n        trade_date = input$trade_date,\n        trade_time = as.POSIXct(paste(input$trade_date, paste0(input$trade_time, \":00\"))),\n        #trade_time = as.POSIXct(paste(input$trade_date, format(input$trade_time, \"%H:%M:%S\"))),\n        entry_price = input$trade_price,\n        exit_price = NA_real_,\n        quantity = input$trade_quantity,\n        target_price = ifelse(input$trade_target > 0, input$trade_target, NA_real_),\n        stop_loss = ifelse(input$trade_stop > 0, input$trade_stop, NA_real_),\n        entry_criteria = input$trade_entry_criteria,\n        scan_source = ifelse(is.null(input$trade_scan_source), \"\", paste(input$trade_scan_source, collapse = \"|\")),\n        notes = input$trade_notes,\n        status = \"open\",\n        pnl = 0,\n        pnl_percent = 0,\n        created_at = Sys.time(),\n        updated_at = Sys.time()\n      )\n      \n      updated_log <- rbind(current_log, new_trade)\n      trading_log(updated_log)\n      \n      # Clear form\n      updateSelectizeInput(session, \"trade_symbol\", selected = \"\")\n      updateNumericInput(session, \"trade_price\", value = 0)\n      updateNumericInput(session, \"trade_quantity\", value = 100)\n      updateNumericInput(session, \"trade_target\", value = 0)\n      updateNumericInput(session, \"trade_stop\", value = 0)\n      updateTextAreaInput(session, \"trade_notes\", value = \"\")\n      updateTextInput(session, \"trade_time\", value = format(Sys.time(), \"%H:%M\"))\n      \n      \n      showNotification(\"Trade added successfully!\", type = \"message\")\n    } else {\n      showNotification(\"Please fill in all required fields (Symbol, Price, Quantity)\", type = \"error\")\n    }\n  })\n  \n  # Get selected trade for editing\n  selected_trade <- reactive({\n    if (!is.null(input$trading_log_table_rows_selected)) {\n      current_log <- filtered_trading_log()\n      if (length(input$trading_log_table_rows_selected) > 0) {\n        return(current_log[input$trading_log_table_rows_selected[1]])\n      }\n    }\n    return(NULL)\n  })\n  \n  # Update trade\n  observeEvent(input$update_trade, {\n    selected <- selected_trade()\n    if (!is.null(selected)) {\n      current_log <- trading_log()\n      trade_id <- selected$trade_id\n      \n      # Update the selected trade\n      current_log[trade_id == trade_id, `:=`(\n        symbol = input$trade_symbol,\n        action = input$trade_action,\n        trade_date = input$trade_date,\n        trade_time = as.POSIXct(paste(input$trade_date, paste0(input$trade_time, \":00\"))),\n        #trade_time = as.POSIXct(paste(input$trade_date, format(input$trade_time, \"%H:%M:%S\"))),\n        entry_price = input$trade_price,\n        quantity = input$trade_quantity,\n        target_price = ifelse(input$trade_target > 0, input$trade_target, NA_real_),\n        stop_loss = ifelse(input$trade_stop > 0, input$trade_stop, NA_real_),\n        entry_criteria = input$trade_entry_criteria,\n        scan_source = ifelse(is.null(input$trade_scan_source), \"\", paste(input$trade_scan_source, collapse = \"|\")),\n        notes = input$trade_notes,\n        updated_at = Sys.time()\n      )]\n      \n      trading_log(current_log)\n      showNotification(\"Trade updated successfully!\", type = \"message\")\n    } else {\n      showNotification(\"Please select a trade to update\", type = \"warning\")\n    }\n  })\n  \n  # Delete trade\n  observeEvent(input$delete_trade, {\n    selected <- selected_trade()\n    if (!is.null(selected)) {\n      current_log <- trading_log()\n      updated_log <- current_log[trade_id != selected$trade_id]\n      trading_log(updated_log)\n      showNotification(\"Trade deleted successfully!\", type = \"message\")\n    } else {\n      showNotification(\"Please select a trade to delete\", type = \"warning\")\n    }\n  })\n  \n  # Filter trading log\n  filtered_trading_log <- reactive({\n    log_data <- trading_log()\n    \n    if (nrow(log_data) == 0) return(log_data)\n    \n    # Apply filters\n    if (!is.null(input$quick_symbol_filter) && length(input$quick_symbol_filter) > 0) {\n      log_data <- log_data[symbol %in% input$quick_symbol_filter]\n    }\n    \n    if (input$quick_status_filter != \"all\") {\n      log_data <- log_data[status == input$quick_status_filter]\n    }\n    \n    if (!is.null(input$quick_date_filter)) {\n      log_data <- log_data[trade_date >= input$quick_date_filter[1] & \n                             trade_date <= input$quick_date_filter[2]]\n    }\n    \n    return(log_data[order(-trade_date, -trade_time)])\n  })\n  \n  # Trading log table\n  # output$trading_log_table <- DT::renderDataTable({\n  #   log_data <- filtered_trading_log()\n  #   \n  #   if (nrow(log_data) > 0) {\n  #     display_data <- log_data[, .(\n  #       ID = trade_id,\n  #       Symbol = symbol,\n  #       Action = toupper(action),\n  #       Date = as.character(trade_date),\n  #       Time = format(trade_time, \"%H:%M\"),\n  #       Entry_Price = sprintf(\"$%.2f\", entry_price),\n  #       Exit_Price = ifelse(is.na(exit_price), \"Open\", sprintf(\"$%.2f\", exit_price)),\n  #       Quantity = quantity,\n  #       Target = ifelse(is.na(target_price), \"N/A\", sprintf(\"$%.2f\", target_price)),\n  #       Stop_Loss = ifelse(is.na(stop_loss), \"N/A\", sprintf(\"$%.2f\", stop_loss)),\n  #       Entry_Criteria = entry_criteria,\n  #       Scan_Source = scan_source,\n  #       Status = toupper(status),\n  #       PnL = ifelse(status == \"open\", \"Open\", sprintf(\"$%.2f\", pnl)),\n  #       PnL_Percent = ifelse(status == \"open\", \"Open\", sprintf(\"%.1f%%\", pnl_percent)),\n  #       Notes = substr(notes, 1, 50)\n  #     )]\n  #     \n  #     DT::datatable(display_data,\n  #                   options = list(pageLength = 15, scrollX = TRUE,\n  #                                  order = list(list(0, 'desc'))),\n  #                   selection = 'single',\n  #                   rownames = FALSE) %>%\n  #       DT::formatStyle('PnL',\n  #                       backgroundColor = DT::styleInterval(0, c('#ffcccc', '#ccffcc'))) %>%\n  #       DT::formatStyle('Status',\n  #                       backgroundColor = DT::styleEqual(c('OPEN', 'CLOSED'), \n  #                                                        c('#ffffcc', '#ccccff')))\n  #   } else {\n  #     DT::datatable(data.frame(Message = \"No trades recorded yet\"))\n  #   }\n  # })\n  # Update the trading log table output to show both manual entries and CSV data\n  output$trading_log_table <- DT::renderDataTable({\n    manual_log <- filtered_trading_log()\n    csv_log <- csv_trading_log()\n    \n    # Combine manual entries and CSV data\n    if (nrow(manual_log) > 0 && nrow(csv_log) > 0) {\n      combined_log <- rbind(manual_log, csv_log)\n      combined_log <- combined_log[order(-trade_date, -trade_time)]\n      # Remove duplicates based on trade_id if they exist\n      combined_log <- combined_log[!duplicated(trade_id)]\n    } else if (nrow(csv_log) > 0) {\n      combined_log <- csv_log\n    } else if (nrow(manual_log) > 0) {\n      combined_log <- manual_log\n    } else {\n      combined_log <- data.table()\n    }\n    \n    if (nrow(combined_log) > 0) {\n      display_data <- combined_log[, .(\n        ID = trade_id,\n        Symbol = symbol,\n        Action = toupper(action),\n        Date = as.character(trade_date),\n        Time = format(trade_time, \"%H:%M\"),\n        Entry_Price = sprintf(\"$%.2f\", entry_price),\n        Exit_Price = ifelse(is.na(exit_price), \"Open\", sprintf(\"$%.2f\", exit_price)),\n        Quantity = quantity,\n        Target = ifelse(is.na(target_price), \"N/A\", sprintf(\"$%.2f\", target_price)),\n        Stop_Loss = ifelse(is.na(stop_loss), \"N/A\", sprintf(\"$%.2f\", stop_loss)),\n        Entry_Criteria = entry_criteria,\n        Scan_Source = scan_source,\n        Status = toupper(status),\n        PnL = ifelse(status == \"open\", \"Open\", sprintf(\"$%.2f\", pnl)),\n        PnL_Percent = ifelse(status == \"open\", \"Open\", sprintf(\"%.1f%%\", pnl_percent)),\n        Notes = substr(notes, 1, 50),\n        Source = ifelse(trade_id %in% manual_log$trade_id, \"Manual\", \"CSV\")\n      )]\n      \n      DT::datatable(display_data,\n                    options = list(pageLength = 15, scrollX = TRUE,\n                                   order = list(list(0, 'desc'))),\n                    selection = 'single',\n                    rownames = FALSE,\n                    caption = \"Trading Log (Manual Entries + CSV Data)\") %>%\n        DT::formatStyle('PnL',\n                        backgroundColor = DT::styleInterval(0, c('#ffcccc', '#ccffcc'))) %>%\n        DT::formatStyle('Status',\n                        backgroundColor = DT::styleEqual(c('OPEN', 'CLOSED'), \n                                                         c('#ffffcc', '#ccccff'))) %>%\n        DT::formatStyle('Source',\n                        backgroundColor = DT::styleEqual(c('Manual', 'CSV'), \n                                                         c('#e6f3ff', '#f0f8e6')))\n    } else {\n      DT::datatable(data.frame(Message = \"No trades found in manual entries or CSV file\"))\n    }\n  })\n  \n  \n  # # P&L Summary\n  # output$pnl_summary <- renderText({\n  #   log_data <- filtered_trading_log()\n  #   \n  #   if (nrow(log_data) == 0) {\n  #     return(\"No trades to analyze\")\n  #   }\n  #   \n  #   closed_trades <- log_data[status == \"closed\" & !is.na(pnl)]\n  #   \n  #   if (nrow(closed_trades) == 0) {\n  #     return(\"No closed trades for P&L analysis\")\n  #   }\n  #   \n  #   total_pnl <- sum(closed_trades$pnl, na.rm = TRUE)\n  #   avg_pnl <- mean(closed_trades$pnl, na.rm = TRUE)\n  #   win_trades <- sum(closed_trades$pnl > 0, na.rm = TRUE)\n  #   loss_trades <- sum(closed_trades$pnl < 0, na.rm = TRUE)\n  #   win_rate <- win_trades / nrow(closed_trades) * 100\n  #   \n  #   paste0(\n  #     \"ðŸ’° P&L SUMMARY:\\n\",\n  #     \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\",\n  #     \"Total P&L: $\", sprintf(\"%.2f\", total_pnl), \"\\n\",\n  #     \"Average P&L per Trade: $\", sprintf(\"%.2f\", avg_pnl), \"\\n\",\n  #     \"Total Trades: \", nrow(closed_trades), \"\\n\",\n  #     \"Winning Trades: \", win_trades, \"\\n\",\n  #     \"Losing Trades: \", loss_trades, \"\\n\",\n  #     \"Win Rate: \", sprintf(\"%.1f%%\", win_rate), \"\\n\",\n  #     \n  #     if (win_trades > 0) {\n  #       paste0(\"Average Win: $\", sprintf(\"%.2f\", mean(closed_trades[pnl > 0]$pnl)), \"\\n\")\n  #     } else \"\",\n  #     \n  #     if (loss_trades > 0) {\n  #       paste0(\"Average Loss: $\", sprintf(\"%.2f\", mean(closed_trades[pnl < 0]$pnl)), \"\\n\")\n  #     } else \"\"\n  #   )\n  # })\n  \n  # Update P&L Summary to use CSV data\n  output$pnl_summary <- renderText({\n    csv_log <- csv_trading_log()\n    \n    if (nrow(csv_log) == 0) {\n      return(\"No CSV trading log found\")\n    }\n    \n    closed_trades <- csv_log[status == \"closed\" & !is.na(pnl)]\n    \n    if (nrow(closed_trades) == 0) {\n      return(\"No closed trades in CSV for P&L analysis\")\n    }\n    \n    total_pnl <- sum(closed_trades$pnl, na.rm = TRUE)\n    avg_pnl <- mean(closed_trades$pnl, na.rm = TRUE)\n    win_trades <- sum(closed_trades$pnl > 0, na.rm = TRUE)\n    loss_trades <- sum(closed_trades$pnl < 0, na.rm = TRUE)\n    win_rate <- win_trades / nrow(closed_trades) * 100\n    \n    avg_win <- if(win_trades > 0) mean(closed_trades[pnl > 0]$pnl) else 0\n    avg_loss <- if(loss_trades > 0) mean(closed_trades[pnl < 0]$pnl) else 0\n    \n    paste0(\n      \"ðŸ’° P&L SUMMARY (CSV Data):\\n\",\n      \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\",\n      \"Total P&L: $\", sprintf(\"%.2f\", total_pnl), \"\\n\",\n      \"Average P&L per Trade: $\", sprintf(\"%.2f\", avg_pnl), \"\\n\",\n      \"Total Closed Trades: \", nrow(closed_trades), \"\\n\",\n      \"Winning Trades: \", win_trades, \"\\n\",\n      \"Losing Trades: \", loss_trades, \"\\n\",\n      \"Win Rate: \", sprintf(\"%.1f%%\", win_rate), \"\\n\",\n      \"Average Win: $\", sprintf(\"%.2f\", avg_win), \"\\n\",\n      \"Average Loss: $\", sprintf(\"%.2f\", avg_loss), \"\\n\",\n      \"Profit Factor: \", sprintf(\"%.2f\", ifelse(avg_loss != 0, abs(avg_win * win_trades / (avg_loss * loss_trades)), 0))\n    )\n  })\n  \n  \n  \n  # # Trade Statistics\n  # output$trade_stats <- renderText({\n  #   log_data <- filtered_trading_log()\n  #   \n  #   if (nrow(log_data) == 0) {\n  #     return(\"No trades to analyze\")\n  #   }\n  #   \n  #   open_trades <- sum(log_data$status == \"open\")\n  #   total_value <- sum(log_data$entry_price * log_data$quantity, na.rm = TRUE)\n  #   \n  #   paste0(\n  #     \"ðŸ“Š TRADE STATISTICS:\\n\",\n  #     \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\",\n  #     \"Total Trades: \", nrow(log_data), \"\\n\",\n  #     \"Open Positions: \", open_trades, \"\\n\",\n  #     \"Closed Positions: \", nrow(log_data) - open_trades, \"\\n\",\n  #     \"Total Trade Value: $\", sprintf(\"%.2f\", total_value), \"\\n\",\n  #     \"Average Position Size: $\", sprintf(\"%.2f\", total_value / nrow(log_data)), \"\\n\",\n  #     \"Most Traded Symbol: \", names(sort(table(log_data$symbol), decreasing = TRUE))[1], \"\\n\",\n  #     \"Most Used Entry Criteria: \", names(sort(table(log_data$entry_criteria), decreasing = TRUE))[1]\n  #   )\n  # })\n  \n  \n  # Update Trade Statistics to use CSV data\n  output$trade_stats <- renderText({\n    csv_log <- csv_trading_log()\n    \n    if (nrow(csv_log) == 0) {\n      return(\"No CSV trading log found\")\n    }\n    \n    open_trades <- sum(csv_log$status == \"open\")\n    total_value <- sum(csv_log$entry_price * csv_log$quantity, na.rm = TRUE)\n    unique_symbols <- length(unique(csv_log$symbol))\n    \n    # Get most frequent values\n    most_traded <- names(sort(table(csv_log$symbol), decreasing = TRUE))[1]\n    most_used_criteria <- names(sort(table(csv_log$entry_criteria), decreasing = TRUE))[1]\n    \n    paste0(\n      \"ðŸ“Š TRADE STATISTICS (CSV Data):\\n\",\n      \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\",\n      \"Total Trades: \", nrow(csv_log), \"\\n\",\n      \"Open Positions: \", open_trades, \"\\n\",\n      \"Closed Positions: \", nrow(csv_log) - open_trades, \"\\n\",\n      \"Unique Symbols: \", unique_symbols, \"\\n\",\n      \"Total Trade Value: $\", sprintf(\"%.2f\", total_value), \"\\n\",\n      \"Average Position Size: $\", sprintf(\"%.2f\", total_value / nrow(csv_log)), \"\\n\",\n      \"Most Traded Symbol: \", most_traded, \"\\n\",\n      \"Most Used Entry Criteria: \", most_used_criteria\n    )\n  })\n  \n  # Download handler\n  output$download_trades <- downloadHandler(\n    filename = function() {\n      paste(\"trading_log_\", Sys.Date(), \".csv\", sep = \"\")\n    },\n    content = function(file) {\n      log_data <- filtered_trading_log()\n      if (nrow(log_data) > 0) {\n        write.csv(log_data, file, row.names = FALSE)\n      } else {\n        write.csv(data.frame(Message = \"No trades to export\"), file, row.names = FALSE)\n      }\n    }\n  )\n  \n  # Performance Charts\n  # output$pnl_chart <- renderPlot({\n  #   log_data <- filtered_trading_log()\n  #   closed_trades <- log_data[status == \"closed\" & !is.na(pnl)][order(trade_date)]\n  #   \n  #   if (nrow(closed_trades) > 0) {\n  #     closed_trades[, cumulative_pnl := cumsum(pnl)]\n  #     \n  #     plot(1:nrow(closed_trades), closed_trades$cumulative_pnl, type = \"l\",\n  #          main = \"Cumulative P&L\", xlab = \"Trade Number\", ylab = \"Cumulative P&L ($)\",\n  #          col = \"blue\", lwd = 2)\n  #     abline(h = 0, col = \"red\", lty = 2)\n  #     points(1:nrow(closed_trades), closed_trades$cumulative_pnl, pch = 16, col = \"blue\")\n  #   } else {\n  #     plot(1, 1, type = \"n\", main = \"No Closed Trades\", xlab = \"\", ylab = \"\")\n  #     text(1, 1, \"No closed trades\\nfor P&L analysis\", cex = 1.2)\n  #   }\n  # })\n  \n  #Update P&L Chart to use CSV data\n  output$pnl_chart <- renderPlot({\n    csv_log <- csv_trading_log()\n    closed_trades <- csv_log[status == \"closed\" & !is.na(pnl)][order(trade_date)]\n    \n    if (nrow(closed_trades) > 0) {\n      closed_trades[, cumulative_pnl := cumsum(pnl)]\n      \n      plot(1:nrow(closed_trades), closed_trades$cumulative_pnl, type = \"l\",\n           main = \"Cumulative P&L (CSV Data)\", xlab = \"Trade Number\", ylab = \"Cumulative P&L ($)\",\n           col = \"blue\", lwd = 2)\n      abline(h = 0, col = \"red\", lty = 2)\n      points(1:nrow(closed_trades), closed_trades$cumulative_pnl, pch = 16, col = \"blue\")\n      \n      # Add trend line\n      if (nrow(closed_trades) > 2) {\n        trend <- lm(cumulative_pnl ~ I(1:nrow(closed_trades)), data = closed_trades)\n        abline(trend, col = \"green\", lty = 2)\n      }\n    } else {\n      plot(1, 1, type = \"n\", main = \"No Closed Trades in CSV\", xlab = \"\", ylab = \"\")\n      text(1, 1, \"No closed trades\\nfound in CSV file\", cex = 1.2)\n    }\n  })\n  \n  # output$win_loss_chart <- renderPlot({\n  #   log_data <- filtered_trading_log()\n  #   closed_trades <- log_data[status == \"closed\" & !is.na(pnl)]\n  #   \n  #   if (nrow(closed_trades) > 0) {\n  #     wins <- sum(closed_trades$pnl > 0)\n  #     losses <- sum(closed_trades$pnl < 0)\n  #     \n  #     pie_data <- c(wins, losses)\n  #     pie_labels <- c(paste(\"Wins (\", wins, \")\", sep = \"\"),\n  #                     paste(\"Losses (\", losses, \")\", sep = \"\"))\n  #     pie_colors <- c(\"#66cc66\", \"#ff6666\")\n  #     \n  #     pie(pie_data, labels = pie_labels, col = pie_colors,\n  #         main = paste(\"Win/Loss Ratio:\", round(wins/(wins+losses)*100, 1), \"% Wins\"))\n  #   } else {\n  #     plot(1, 1, type = \"n\", main = \"No Closed Trades\", xlab = \"\", ylab = \"\")\n  #   }\n  # })\n  # \n  # output$entry_criteria_chart <- renderPlot({\n  #   log_data <- filtered_trading_log()\n  #   \n  #   if (nrow(log_data) > 0) {\n  #     criteria_counts <- table(log_data$entry_criteria)\n  #     barplot(criteria_counts, main = \"Entry Criteria Usage\",\n  #             las = 2, col = \"lightblue\", ylab = \"Number of Trades\")\n  #   }\n  # })\n  output$win_loss_chart <- renderPlot({\n    csv_log <- csv_trading_log()\n    closed_trades <- csv_log[status == \"closed\" & !is.na(pnl)]\n    \n    if (nrow(closed_trades) > 0) {\n      wins <- sum(closed_trades$pnl > 0)\n      losses <- sum(closed_trades$pnl < 0)\n      breakeven <- sum(closed_trades$pnl == 0)\n      \n      if (wins + losses + breakeven > 0) {\n        pie_data <- c(wins, losses, breakeven)\n        pie_labels <- c(paste(\"Wins (\", wins, \")\", sep = \"\"),\n                        paste(\"Losses (\", losses, \")\", sep = \"\"),\n                        paste(\"Breakeven (\", breakeven, \")\", sep = \"\"))\n        pie_colors <- c(\"#66cc66\", \"#ff6666\", \"#ffff66\")\n        \n        # Remove zero values\n        non_zero <- pie_data > 0\n        pie_data <- pie_data[non_zero]\n        pie_labels <- pie_labels[non_zero]\n        pie_colors <- pie_colors[non_zero]\n        \n        pie(pie_data, labels = pie_labels, col = pie_colors,\n            main = paste(\"Win/Loss Ratio:\", round(wins/(wins+losses)*100, 1), \"% Wins\"))\n      }\n    } else {\n      plot(1, 1, type = \"n\", main = \"No Closed Trades in CSV\", xlab = \"\", ylab = \"\")\n      text(1, 1, \"No closed trades\\nfound in CSV file\", cex = 1.2)\n    }\n  })\n  \n  # Update Entry Criteria Chart to use CSV data\n  output$entry_criteria_chart <- renderPlot({\n    csv_log <- csv_trading_log()\n    \n    if (nrow(csv_log) > 0) {\n      criteria_counts <- table(csv_log$entry_criteria)\n      barplot(criteria_counts, main = \"Entry Criteria Usage (CSV Data)\",\n              las = 2, col = \"lightblue\", ylab = \"Number of Trades\")\n    } else {\n      plot(1, 1, type = \"n\", main = \"No CSV Data\", xlab = \"\", ylab = \"\")\n      text(1, 1, \"No trading log CSV\\nfile found\", cex = 1.2)\n    }\n  })\n  \n  \n  # output$scan_source_chart <- renderPlot({\n  #   log_data <- filtered_trading_log()\n  #   \n  #   if (nrow(log_data) > 0) {\n  #     # Parse scan sources (handle multiple sources separated by |)\n  #     all_sources <- unlist(strsplit(log_data$scan_source, \"\\\\|\"))\n  #     all_sources <- all_sources[all_sources != \"\"]\n  #     \n  #     if (length(all_sources) > 0) {\n  #       source_counts <- table(all_sources)\n  #       barplot(source_counts, main = \"Scan Source Usage\",\n  #               las = 2, col = \"lightgreen\", ylab = \"Number of Trades\")\n  #     }\n  #   }\n  # })\n  \n  # Update Scan Source Chart to use CSV data  \n  output$scan_source_chart <- renderPlot({\n    csv_log <- csv_trading_log()\n    \n    if (nrow(csv_log) > 0) {\n      # Parse scan sources (handle multiple sources separated by |)\n      all_sources <- unlist(strsplit(csv_log$scan_source, \"\\\\|\"))\n      all_sources <- all_sources[all_sources != \"\"]\n      \n      if (length(all_sources) > 0) {\n        source_counts <- table(all_sources)\n        barplot(source_counts, main = \"Scan Source Usage (CSV Data)\",\n                las = 2, col = \"lightgreen\", ylab = \"Number of Trades\")\n      }\n    } else {\n      plot(1, 1, type = \"n\", main = \"No CSV Data\", xlab = \"\", ylab = \"\")\n      text(1, 1, \"No trading log CSV\\nfile found\", cex = 1.2)\n    }\n  })\n  \n  \n  \n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n","type":"text"}]
